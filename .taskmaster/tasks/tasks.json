{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "OTP 환경 및 프로젝트 초기화",
        "description": "OpenTripPlanner(OTP) 2.2+ 환경을 Java 21 및 Docker 기반으로 초기화하고, 프로젝트 구조를 세팅합니다.",
        "details": "Dockerfile을 작성하여 Java 21 기반 OTP 이미지를 빌드합니다. 프로젝트 루트에 docker-compose.yml을 생성하여 OTP 서버 컨테이너를 정의합니다. OTP 공식 문서에 따라 환경변수 및 볼륨 마운트 경로를 설정합니다.",
        "testStrategy": "Docker 컨테이너 실행 후 OTP 서버가 정상적으로 기동되는지, /otp/routers/default/health 엔드포인트에서 상태 확인.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Java 21 및 OTP 기반 Dockerfile 작성",
            "description": "OpenTripPlanner(OTP) 2.2+ 버전을 실행하기 위한 Java 21 환경의 Dockerfile을 정의합니다. OTP JAR 파일을 다운로드하고 실행 가능한 환경을 구성합니다.",
            "dependencies": [],
            "details": "공식 `eclipse-temurin:21-jre-jammy` 이미지를 기반으로 Dockerfile을 작성합니다. `ARG`를 사용하여 OTP 버전을 동적으로 지정하고, `wget` 또는 `curl`을 사용하여 Maven Central에서 지정된 버전의 OTP JAR 파일을 다운로드합니다.",
            "status": "done",
            "testStrategy": "`docker build . -t otp-server` 명령어를 실행하여 이미지가 오류 없이 성공적으로 빌드되는지 확인합니다.",
            "updatedAt": "2025-10-12T17:20:04.317Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "OTP 데이터 및 설정용 디렉토리 구조 생성",
            "description": "OTP의 그래프 데이터(GTFS, OSM)와 설정 파일을 관리하기 위한 호스트 머신의 디렉토리 구조를 생성합니다. 이 구조는 Docker 컨테이너에 볼륨으로 마운트됩니다.",
            "dependencies": [],
            "details": "프로젝트 루트에 `otp_data` 디렉토리를 생성하고, 그 하위에 `graphs/default`, `gtfs`, `osm` 디렉토리를 순차적으로 생성합니다. `graphs/default` 디렉토리는 OTP가 빌드한 그래프 파일과 설정 파일을 저장하는 데 사용됩니다.",
            "status": "done",
            "testStrategy": "`ls -R otp_data` 명령어를 실행하여 `otp_data/graphs/default`, `otp_data/gtfs`, `otp_data/osm` 디렉토리 구조가 올바르게 생성되었는지 확인합니다.",
            "parentId": "undefined",
            "updatedAt": "2025-10-12T17:20:23.664Z"
          },
          {
            "id": 3,
            "title": "OTP 서버 및 그래프 빌드 기본 설정 파일 생성",
            "description": "OTP 서버의 기본 동작을 정의하는 `otp-config.json`과 그래프 데이터 빌드 설정을 위한 `build-config.json`의 초기 템플릿 파일을 생성합니다.",
            "dependencies": [
              2
            ],
            "details": "`otp_data/graphs/default` 디렉토리 내에 비어 있거나 최소한의 설정만 포함된 `build-config.json`과 `otp-config.json` 파일을 생성합니다. `otp-config.json`에는 라우터 설정(`routingDefaults`)과 같은 기본 구조를 포함시킵니다.",
            "status": "done",
            "testStrategy": "생성된 JSON 파일들이 유효한 형식인지 `jq . otp_data/graphs/default/*.json`과 같은 JSON 파싱 도구를 사용하여 검증합니다.",
            "parentId": "undefined",
            "updatedAt": "2025-10-12T17:23:39.788Z"
          },
          {
            "id": 4,
            "title": "Docker Compose를 이용한 OTP 서비스 정의",
            "description": "OTP 서버 컨테이너를 쉽게 실행하고 관리할 수 있도록 `docker-compose.yml` 파일을 작성합니다. 포트 매핑, 볼륨 마운트, 환경 변수 설정을 포함합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "프로젝트 루트에 `docker-compose.yml` 파일을 생성합니다. Subtask 1에서 작성한 Dockerfile을 `build` 컨텍스트로 지정합니다. `8080:8080` 포트를 매핑하고, `otp_data` 디렉토리를 컨테이너의 `/var/otp` 경로에 마운트합니다. `JAVA_OPTS` 환경 변수를 사용하여 OTP 서버의 힙 메모리(-Xmx, -Xms)를 설정합니다.",
            "status": "done",
            "testStrategy": "`docker-compose config` 명령어를 실행하여 `docker-compose.yml` 파일의 구문이 유효하고 설정이 올바르게 로드되는지 확인합니다.",
            "parentId": "undefined",
            "updatedAt": "2025-10-12T17:27:26.616Z"
          },
          {
            "id": 5,
            "title": "OTP 컨테이너 초기 실행 및 상태 확인",
            "description": "작성된 `docker-compose.yml`을 사용하여 OTP 컨테이너를 실행하고, 서버 애플리케이션이 정상적으로 기동되는지 기본 엔드포인트를 통해 확인합니다.",
            "dependencies": [
              3,
              4
            ],
            "details": "`docker-compose up` 명령어를 사용하여 OTP 컨테이너를 실행합니다. 컨테이너 로그를 확인하여 JVM 관련 에러 없이 서버가 시작되는지 확인합니다. `curl http://localhost:8080/otp`를 호출하여 OTP 관련 응답(예: 404 Not Found, 라우터가 없다는 메시지)이 수신되는지 확인하여 서비스 기동을 검증합니다.",
            "status": "done",
            "testStrategy": "`docker-compose ps` 명령으로 컨테이너가 'Up' 상태인지 확인하고, `curl -I http://localhost:8080/otp`를 통해 HTTP 응답 코드를 확인하여 서비스가 실행 중인지 검증합니다.",
            "parentId": "undefined",
            "updatedAt": "2025-10-12T17:38:06.305Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "OTP 환경 초기화를 위한 Dockerfile 및 docker-compose.yml 작성, 볼륨 마운트 설정, 초기 OTP 설정 파일 생성, 그리고 서비스 기동 및 헬스체크 확인 단계를 더 상세히 정의할 수 있습니다.",
        "updatedAt": "2025-10-12T17:38:06.305Z"
      },
      {
        "id": 2,
        "title": "한국 GTFS 및 OSM 데이터 수집 및 검증",
        "description": "한국 대중교통 GTFS 데이터와 OpenStreetMap(OSM) 데이터를 수집하고, OTP에서 요구하는 포맷으로 검증합니다.",
        "details": "GTFS 데이터는 국토교통부 또는 서울 열린데이터광장 등에서 최신 버전을 다운로드합니다. OSM 데이터는 Geofabrik 등에서 서울/한국 지역을 추출합니다. 데이터 무결성 및 포맷(경로, 정류장, 일정 등) 검증 스크립트 작성.",
        "testStrategy": "GTFS 및 OSM 파일을 OTP에 로드하여 오류 메시지 없이 그래프 빌드가 가능한지 확인.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "한국 GTFS 데이터 소스 조사 및 다운로드",
            "description": "최신 한국 대중교통 GTFS 데이터를 제공하는 공식 소스(예: 서울시 열린데이터광장, 국토교통부)를 조사하고, 최신 버전의 데이터를 다운로드합니다.",
            "dependencies": [],
            "details": "서울시 열린데이터광장 또는 국가대중교통정보센터(TAGO) 포털을 방문하여 수도권 GTFS 데이터셋을 찾습니다. 다운로드 URL을 기록하고, `gtfs.zip` 파일을 로컬에 저장합니다.",
            "status": "done",
            "testStrategy": "다운로드한 zip 파일의 압축을 해제하여 'stops.txt', 'routes.txt', 'trips.txt' 등 필수 파일이 포함되어 있는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "한국 지역 OSM 데이터 추출 및 다운로드",
            "description": "OpenTripPlanner에 필요한 도로망 데이터를 위해 한국 지역의 OpenStreetMap(OSM) 데이터를 다운로드합니다.",
            "dependencies": [],
            "details": "Geofabrik (download.geofabrik.de)에서 한국(South Korea) 지역의 최신 OSM 데이터를 '.pbf' 형식으로 다운로드합니다. 파일 이름은 'korea-latest.osm.pbf'와 같은 명확한 이름으로 저장합니다.",
            "status": "done",
            "testStrategy": "다운로드한 '.pbf' 파일의 크기가 비정상적으로 작지 않은지 (최소 수백 MB 이상) 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "OTP 프로젝트 데이터 디렉토리 구성",
            "description": "다운로드한 GTFS 및 OSM 데이터를 OTP가 인식할 수 있는 프로젝트 내 특정 디렉토리에 배치합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "프로젝트 루트의 'data' 디렉토리에 다운로드한 GTFS zip 파일과 OSM .pbf 파일을 이동시킵니다. 이 경로는 'docker-compose.yml'에 정의된 OTP 컨테이너의 볼륨 마운트 경로와 일치해야 합니다.",
            "status": "done",
            "testStrategy": "`ls -l data/` 명령어를 실행하여 GTFS와 OSM 파일이 모두 존재하는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "OTP를 이용한 데이터 유효성 검증 및 초기 그래프 빌드",
            "description": "준비된 GTFS 및 OSM 데이터를 사용하여 OpenTripPlanner 서버를 실행하고, 데이터 로딩 및 그래프 빌드 과정에서 오류가 없는지 확인합니다.",
            "dependencies": [
              3
            ],
            "details": "프로젝트 루트에서 `docker-compose up` 명령을 실행하여 OTP 컨테이너를 시작합니다. 컨테이너 로그를 실시간으로 모니터링하며 데이터 파싱 과정과 그래프 빌드 완료 메시지를 확인합니다.",
            "status": "done",
            "testStrategy": "OTP 서버 로그에서 심각한(SEVERE) 오류나 예외 없이 'Grizzly server running' 및 그래프 빌드 관련 로그가 정상적으로 출력되는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "데이터 수집 자동화 쉘 스크립트 작성",
            "description": "향후 데이터 업데이트를 용이하게 하기 위해, GTFS 및 OSM 데이터를 자동으로 다운로드하여 'data' 디렉토리에 배치하는 쉘 스크립트를 작성합니다.",
            "dependencies": [
              1,
              2,
              4
            ],
            "details": "'scripts/download_data.sh' 파일을 생성합니다. `curl` 또는 `wget` 명령어를 사용하여 1, 2번 태스크에서 확정한 URL로부터 데이터를 다운로드하고 'data' 디렉토리에 저장합니다. 스크립트에 실행 권한(`chmod +x`)을 부여합니다.",
            "status": "done",
            "testStrategy": "기존 'data' 디렉토리를 비운 후 `./scripts/download_data.sh` 스크립트를 실행하여 GTFS 및 OSM 파일이 정상적으로 다운로드되는지 확인합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "한국 GTFS 및 OSM 데이터 소스 조사 및 다운로드, 프로젝트 디렉토리 구성, OTP를 이용한 초기 데이터 유효성 검증, 그리고 데이터 수집 자동화 스크립트 개발 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 3,
        "title": "OTP 그래프 빌드 및 데이터 통합 자동화",
        "description": "수집한 GTFS/OSM 데이터를 기반으로 OTP 그래프 빌드 프로세스를 자동화합니다.",
        "details": "Docker 컨테이너 내에서 GTFS/OSM 데이터를 지정 경로에 배치하고, OTP의 graph-builder 명령어를 통해 그래프를 생성하는 스크립트 작성. 빌드 결과물(graph.obj 등)을 서버 실행에 활용.",
        "testStrategy": "그래프 빌드 완료 후, OTP 서버에서 경로 탐색 및 isochrone API 호출이 정상적으로 동작하는지 확인.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "GTFS/OSM 데이터 컨테이너 내 경로 설정 및 검증",
            "description": "OTP 그래프 빌더가 GTFS 및 OSM 데이터를 읽을 수 있도록 Docker 컨테이너 내 파일 시스템 경로를 정의하고, Task 2에서 수집된 데이터가 해당 경로로 정상적으로 마운트/복사되는지 확인합니다. docker-compose.yml의 볼륨 설정을 검토하고 필요시 수정합니다.",
            "dependencies": [],
            "details": "`docker-compose.yml`에서 OTP 컨테이너 내부에 `/otp/graphs/default/data/gtfs` 및 `/otp/graphs/default/data/osm`와 같은 경로에 호스트의 데이터 디렉토리를 마운트하도록 설정합니다. `docker exec` 명령어를 사용하여 컨테이너 내부에서 데이터 파일 접근 가능 여부를 확인합니다.",
            "status": "done",
            "testStrategy": "컨테이너가 실행 중인 상태에서 `docker exec <container_id> ls -l /otp/graphs/default/data/gtfs` 명령어를 실행하여 GTFS 파일 목록이 정상적으로 표시되는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "OTP 그래프 빌드 쉘 스크립트 개발",
            "description": "OTP의 graph-builder 기능을 활용하여 GTFS 및 OSM 데이터를 기반으로 교통 그래프를 빌드하는 쉘 스크립트(예: `build_graph.sh`)를 작성합니다. 이 스크립트는 OTP 실행 환경 설정 및 빌드 명령어를 포함해야 합니다.",
            "dependencies": [
              1
            ],
            "details": "`otp-2.2.0-shaded.jar` 파일을 실행하며 `build --basePath /otp --router default --graphPath /otp/graphs/default/ --in/gtfs /otp/graphs/default/data/gtfs --in/osm /otp/graphs/default/data/osm`와 유사한 명령어를 사용합니다. 빌드 중 메모리 부족을 방지하기 위해 `JAVA_OPTS` 환경변수에 `\"-Xmx4G\"` 등을 설정하여 스크립트에 포함합니다.",
            "status": "done",
            "testStrategy": "작성된 스크립트를 수동으로 실행하여 그래프 빌드가 성공적으로 완료되고, 지정된 출력 경로(예: `/otp/graphs/default/`)에 `graph.obj` 파일이 생성되는지 확인합니다. 빌드 로그에 에러가 없는지 검토합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Docker Compose 그래프 빌드 서비스 통합",
            "description": "작성된 그래프 빌드 쉘 스크립트를 실행하는 별도의 Docker Compose 서비스를 `docker-compose.yml`에 추가합니다. 이 서비스는 GTFS/OSM 데이터 볼륨과 빌드 결과물 저장용 볼륨에 접근할 수 있도록 설정해야 합니다.",
            "dependencies": [
              2
            ],
            "details": "`docker-compose.yml`에 `graph-builder` 또는 `otp-builder`라는 이름의 서비스를 추가하고, `command` 필드에 `build_graph.sh` 스크립트 실행 명령어를 지정합니다. `volumes` 설정을 통해 GTFS/OSM 데이터 볼륨과 빌드된 `graph.obj` 파일이 저장될 영구 볼륨을 공유하도록 구성합니다.",
            "status": "done",
            "testStrategy": "`docker-compose up otp-builder` 명령어를 실행하여 빌드 서비스가 성공적으로 그래프를 생성하고 종료되는지 확인합니다. 이후 해당 볼륨 마운트 경로에 `graph.obj` 파일이 정상적으로 생성 및 저장되었는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "OTP 서버용 빌드된 그래프 로드 설정",
            "description": "Docker Compose 내 OTP 서버 서비스가 이전에 `graph-builder` 서비스에 의해 생성된 `graph.obj` 파일을 자동으로 로드하도록 설정합니다. OTP 서버의 설정 파일을 업데이트하거나 서버 시작 명령을 조정하여 그래프 파일 경로를 지정합니다.",
            "dependencies": [
              3
            ],
            "details": "OTP 서버 서비스의 `command` 또는 환경변수를 통해 `graph.obj` 파일이 위치한 경로(예: `/otp/graphs/default/graph.obj`)를 지정하여 서버 시작 시 로드되도록 합니다. `router-config.json`에 `graphPath`를 설정하거나, OTP 서버 시작 명령에 `--graph /path/to/graph.obj` 옵션을 추가합니다.",
            "status": "done",
            "testStrategy": "`docker-compose up otp-server` (또는 전체 `docker-compose up`) 실행 후, OTP 서버 컨테이너의 로그에서 `graph.obj` 파일 로딩 관련 메시지(예: \"Graph loaded successfully\")를 확인하여 그래프 로드 성공 여부를 검증합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "전체 빌드 및 서버 실행 워크플로우 자동화 검증",
            "description": "데이터 준비부터 그래프 빌드, 그리고 빌드된 그래프를 사용하는 OTP 서버 실행까지의 전체 자동화 워크플로우를 엔드투엔드로 검증합니다. 모든 과정이 스크립트와 Docker Compose만으로 자동 실행되고 성공적으로 완료되는지 확인합니다.",
            "dependencies": [
              4
            ],
            "details": "`docker-compose down -v` 명령어로 모든 볼륨을 제거한 후, `docker-compose up --build -d` 명령어를 통해 모든 과정을 초기부터 실행합니다. OTP 서버가 완전히 기동된 후, `/otp/routers/default/health` 엔드포인트에 접속하여 상태를 확인하고, 간단한 경로 탐색 (예: `http://localhost:8080/otp/routers/default/plan?fromPlace=37.5,127.0&toPlace=37.6,127.1`) 또는 isochrone API를 호출하여 그래프가 정상 작동하는지 확인합니다.",
            "status": "done",
            "testStrategy": "OTP 서버의 health check 엔드포인트가 `{\"status\":\"OK\"}`를 반환하는지 확인하고, 실제 경로 탐색 API 호출이 유효한 계획 응답(예: 경로 정보, 시간 등)을 반환하는지 검증합니다. 빌드 및 서버 기동 과정에서 발생하는 모든 로그를 검토하여 에러가 없는지 확인합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "GTFS/OSM 데이터 컨테이너 내 경로 설정 및 검증, OTP 그래프 빌드 쉘 스크립트 개발, Docker Compose 빌드 서비스 통합, 빌드된 그래프 로드 설정, 그리고 전체 워크플로우 자동화 검증 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 4,
        "title": "FastAPI 기반 Isochrone API 래퍼 구현",
        "description": "FastAPI 애플리케이션에 `/api/isochrone` 엔드포인트를 구현하여 내부 OTP 2.5.0의 TravelTime Sandbox API(`/otp/traveltime/isochrone`)를 호출하고 결과를 반환합니다.",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "high",
        "details": "기존 `backend` 디렉토리의 Spring Boot 코드를 FastAPI 애플리케이션으로 교체합니다. FastAPI 애플리케이션은 사용자의 요청(`fromPlace`, `mode`, `cutoffSec`)을 받아 OTP 2.5.0의 TravelTime Sandbox API 형식으로 변환하여 `http://otp:8080/otp/traveltime/isochrone` 엔드포인트를 호출합니다. 변환 로직은 `fromPlace`를 `location`으로, `cutoffSec`을 ISO-8601 형식의 `cutoff`(예: 'PT1800S')로, `mode`를 `modes` 파라미터(예: 'WALK,TRANSIT')로 매핑하는 것을 포함합니다. `httpx.AsyncClient`를 사용하여 `isochrone-internal` Docker 네트워크를 통해 OTP 서비스를 호출하며, 타임아웃 및 재시도 로직을 포함합니다. API 라우터에서는 Pydantic 모델을 사용하여 요청 파라미터를 검증하고, OTP 호출 실패 시 적절한 HTTP 예외를 반환합니다. OTP 호스트(`http://otp:8080`)와 같은 설정은 환경 변수를 통해 주입합니다.",
        "testStrategy": "`pytest`와 `httpx`의 `AsyncClient`를 모킹(mocking)하여 OTP API 호출 및 파라미터 변환 로직을 단위 테스트합니다. `docker-compose up`으로 전체 서비스를 실행한 후, `curl 'http://localhost:8080/api/isochrone?fromPlace=37.5665,126.9780&mode=TRANSIT&cutoffSec=1800'`와 같이 외부로 노출된 백엔드 엔드포인트를 호출하여, 요청이 OTP TravelTime API에 맞게 변환되고 응답이 정상적으로 프록시되는지 통합 테스트합니다.",
        "subtasks": [
          {
            "id": 1,
            "title": "docker-compose.yml OTP 서비스 포트(8080) 노출 설정",
            "description": "docker-compose.yml 파일에서 주석 처리된 'ports' 설정을 활성화하여 OTP 컨테이너의 8080 포트를 호스트 머신에 바인딩합니다. 이는 백엔드 개발 및 E2E 테스트 시 호스트에서 OTP API에 직접 접근하여 동작을 확인하는 데 사용됩니다.",
            "status": "done",
            "dependencies": [],
            "details": "docker-compose.yml 파일의 otp 서비스 정의에서 'ports: - \"8080:8080\"' 라인의 주석을 제거하고 'docker-compose up -d --build' 명령어로 서비스를 재시작합니다.\n<info added on 2025-11-17T15:39:53.368Z>\n기존 계획을 변경하여, OTP 서비스의 포트를 호스트에 직접 노출하지 않도록 했습니다. 대신 `docker-compose.yml`에 `isochrone-internal`이라는 공용 네트워크를 생성하고, `otp`, `backend`, `graph-builder` 서비스가 이 네트워크를 사용하도록 설정했습니다. 이 변경으로 인해 서비스들은 Docker 네트워크 내에서 서비스 이름(예: `http://otp:8080`)을 통해 서로 통신하게 됩니다. 호스트에는 `backend` 서비스의 8080 포트만 노출되어, 서비스 간 통신은 격리되고 외부 접근은 백엔드 API로 단일화됩니다.\n</info added on 2025-11-17T15:39:53.368Z>",
            "testStrategy": "`docker ps` 명령어를 실행하여 otp 컨테이너의 PORTS 항목에 '0.0.0.0:8080->8080/tcp'와 같이 포트 포워딩이 정상적으로 설정되었는지 확인합니다."
          },
          {
            "id": 2,
            "title": "OTP API 연동 클라이언트 구현 및 예외 처리",
            "description": "`WebClient` 또는 `RestTemplate`을 사용하여 Docker 네트워크상의 OTP 서비스(`http://otp:8080/otp/routers/default/isochrone`)를 호출하는 `OtpClient` 컴포넌트를 구현합니다. OTP 서버의 응답이 없거나 오류(5xx, 4xx)가 발생했을 때, 커스텀 예외를 발생시키고 에러 로그를 기록하는 등 견고한 예외 처리 로직을 추가합니다.",
            "status": "done",
            "dependencies": [],
            "details": "`@Component` 어노테이션을 사용하여 `OtpClient.java`를 생성합니다. `application.yml` 또는 `application.properties`에 OTP 서버의 주소(`otp.api.url=http://otp:8080`)를 설정하고 `@Value`로 주입받아 사용합니다. OTP 통신 실패 시 `OtpClientException`과 같은 커스텀 예외를 정의하여 사용합니다.",
            "testStrategy": "WireMock 또는 MockWebServer를 사용하여 OTP API를 모킹(mocking)하고, 클라이언트가 성공, 실패, 타임아웃 등 다양한 시나리오에서 올바르게 동작하는지 단위 테스트로 검증합니다."
          },
          {
            "id": 3,
            "title": "백엔드 API E2E 테스트 및 문서화",
            "description": "Postman 또는 `curl`을 사용하여 로컬에서 실행된 백엔드 애플리케이션의 `/api/isochrone` 엔드포인트를 직접 호출합니다. `docker-compose`로 모든 서비스(otp, backend)가 실행 중인 상태에서, 요청이 백엔드를 거쳐 OTP까지 전달되고 최종 응답이 클라이언트에게 성공적으로 반환되는지 End-to-End 흐름을 검증합니다. `README.md`에 새로운 API 엔드포인트, 파라미터, 사용 예시를 업데이트합니다.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "FastAPI 백엔드가 `docker-compose`를 통해 실행 중인 상태에서, Postman 또는 curl을 사용하여 `http://localhost:8080/api/isochrone?fromPlace=37.5665,126.9780&mode=TRANSIT&cutoffSec=1800`와 같은 실제 사용 예시 요청을 보냅니다. FastAPI 애플리케이션이 내부적으로 파라미터를 변환하여 OTP 2.5.0의 TravelTime API와 통신하고, 유효한 GeoJSON 폴리곤을 반환하는지 확인합니다. `README.md`의 API 사용법 섹션을 FastAPI 버전에 맞게 수정합니다.\n<info added on 2025-11-17T15:40:41.055Z>\n사용자 피드백 반영: 백엔드 포트는 `8081`이 아닌 `8080`을 사용합니다. Postman/curl 테스트 시 사용할 예시 URL을 `http://localhost:8080/api/isochrone?fromPlace=37.5665,126.9780&mode=TRANSIT&cutoffSec=1800`로 수정합니다. `README.md` 문서 업데이트 시에도 `8080` 포트를 기준으로 작성합니다. E2E 테스트는 `docker-compose` 환경에서 외부로 노출된 `backend` 서비스(`localhost:8080`)를 대상으로 하며, `backend`가 내부 네트워크를 통해 OTP 서비스와 통신하는 흐름을 검증합니다.\n</info added on 2025-11-17T15:40:41.055Z>",
            "testStrategy": "실제 좌표와 파라미터로 API를 호출하여 유효한 GeoJSON 응답을 받는지 확인합니다. 잘못된 파라미터(예: `fromPlace` 누락)를 보냈을 때 FastAPI가 Pydantic 검증을 통해 반환하는 422 Unprocessable Entity 응답이 정상적으로 오는지 확인합니다."
          },
          {
            "id": 5,
            "title": "Isochrone API 라우터 및 Pydantic 모델 구현",
            "description": "FastAPI의 `APIRouter`를 사용하여 `/api/isochrone` 엔드포인트를 구현합니다. Pydantic 모델을 사용하여 요청 쿼리 파라미터(`fromPlace`, `mode`, `cutoffSec` 등)의 타입과 유효성을 검증합니다.",
            "status": "done",
            "dependencies": [],
            "details": "별도의 `router` 모듈(`backend/app/api/routes/isochrone.py`)에 isochrone 라우터를 정의합니다. `fromPlace`는 `str`로, `mode`는 `Literal['TRANSIT', 'WALK']`로, `cutoffSec`는 `int`로 받는 Pydantic 모델을 사용합니다. 라우터 핸들러 함수 내에서, 검증된 입력 파라미터를 OTP TravelTime API의 요구사항에 맞게 변환하는 로직(예: `cutoffSec`를 `PT{seconds}S` 형태의 ISO-8601 기간 문자열로 변환)을 구현합니다.",
            "testStrategy": "단위 테스트(`pytest`)를 통해 유효한 파라미터와 유효하지 않은 파라미터를 각각 전달했을 때, 라우터가 서비스 로직을 호출하거나 422 에러를 올바르게 반환하는지 검증합니다."
          },
          {
            "id": 6,
            "title": "OTP 2.5.0 TravelTime API 연동을 위한 비동기 클라이언트 구현",
            "description": "`httpx.AsyncClient`를 사용하여 OTP 서비스의 `/otp/traveltime/isochrone` 엔드포인트를 비동기적으로 호출하는 클라이언트 모듈을 구현합니다. OTP 서버의 응답이 없거나 오류가 발생했을 때의 예외 처리를 포함합니다.",
            "status": "done",
            "dependencies": [],
            "details": "OTP 클라이언트 로직을 `backend/app/services/otp_client.py` 모듈로 분리합니다. 이 클라이언트는 라우터로부터 전달받은 파라미터를 OTP API 명세에 맞게 변환하여 `/otp/traveltime/isochrone` 엔드포인트를 호출합니다: `fromPlace` -> `location`, `cutoffSec` -> `cutoff` (ISO-8601), `mode` -> `modes`. `httpx`의 타임아웃 설정을 적용하고, OTP 서버가 4xx/5xx 응답을 반환할 경우 `HTTPException`을 발생시켜 API 사용자에게 적절한 오류를 전달합니다. OTP API URL은 환경 변수에서 읽어와 설정합니다.",
            "testStrategy": "`pytest`와 `pytest-asyncio`를 사용하고, `respx` 또는 `httpx.MockTransport`를 사용하여 OTP API를 모킹합니다. 성공, 서버 오류(500), 클라이언트 오류(400), 타임아웃 등 다양한 시나리오에서 클라이언트가 올바르게 동작하는지 단위 테스트로 검증합니다."
          },
          {
            "id": 7,
            "title": "FastAPI 백엔드 프로젝트 초기 설정",
            "description": "backend 디렉터리에 FastAPI 기반 백엔드 프로젝트를 스캐폴딩하고 필수 의존성을 추가합니다.",
            "status": "done",
            "dependencies": [],
            "details": "uv 기반 Python 3.13 환경을 구성하고 pyproject.toml에 FastAPI, httpx, uvicorn[standard], pydantic-settings 등을 추가합니다. app/, tests/ 디렉터리를 마련하고 main.py 기본 엔트리를 작성한 뒤 docker-compose의 FastAPI 서비스가 uvicorn 명령으로 이 프로젝트를 실행하도록 Dockerfile을 구성합니다. 검증: UV_CACHE_DIR을 지정해 'uv sync'를 실행하고 'uv run uvicorn app.main:app --host 0.0.0.0 --port 8080' 또는 'uv run pytest'로 기동 여부를 확인합니다.",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "FastAPI 라우터 및 OTP 클라이언트 구현",
            "description": "FastAPI 앱에  라우터와 OTP 연동 클라이언트를 추가합니다.",
            "status": "done",
            "dependencies": [],
            "details": "Pydantic 쿼리 모델을 `backend/app/api/models.py`에 정의하고, `backend/app/api/routes/isochrone.py`의 라우터에서 `Depends`를 통해 주입합니다. `backend/app/services/otp_client.py`에 `httpx.AsyncClient`를 이용한 OTP 프록시 클라이언트를 구현합니다. 이 클라이언트는 OTP 2.5.0의 `/otp/traveltime/isochrone` 엔드포인트를 호출하며, `cutoffSec`을 ISO-8601 형식으로 변환하는 등 파라미터 매핑 로직을 포함합니다. 재시도/타임아웃 설정, 환경 변수 기반 설정 로직을 구현하고 GET 핸들러가 OTP 응답을 그대로 전달하도록 구성합니다. 검증: `respx` 또는 `httpx.MockTransport`로 OTP 호출을 모킹한 `pytest` 케이스를 `tests/` 디렉터리에 추가하고, `docker-compose` 환경에서 `curl`로 호출해 실제 응답이 전달되는지 확인합니다.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "OTP API 연동 클라이언트 구현 및 예외 처리",
            "description": "`WebClient` 또는 `RestTemplate`을 사용하여 Docker 네트워크상의 OTP 서비스(`http://otp:8080/otp/routers/default/isochrone`)를 호출하는 `OtpClient` 컴포넌트를 구현합니다. OTP 서버의 응답이 없거나 오류(5xx, 4xx)가 발생했을 때, 커스텀 예외를 발생시키고 에러 로그를 기록하는 등 견고한 예외 처리 로직을 추가합니다.",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "`@Component` 어노테이션을 사용하여 `OtpClient.java`를 생성합니다. `application.yml` 또는 `application.properties`에 OTP 서버의 주소(`otp.api.url=http://otp:8080`)를 설정하고 `@Value`로 주입받아 사용합니다. OTP 통신 실패 시 `OtpClientException`과 같은 커스텀 예외를 정의하여 사용합니다.",
            "testStrategy": "WireMock 또는 MockWebServer를 사용하여 OTP API를 모킹(mocking)하고, 클라이언트가 성공, 실패, 타임아웃 등 다양한 시나리오에서 올바르게 동작하는지 단위 테스트로 검증합니다."
          }
        ]
      },
      {
        "id": 5,
        "title": "API 파라미터 검증 및 입력 유효성 처리",
        "description": "API 요청 시 입력되는 파라미터(좌표, 시간, 이동수단 등)의 유효성 검증 로직을 구현합니다.",
        "details": "REST API 호출 시 필수 파라미터 누락, 범위 오류, 지원하지 않는 이동수단 등 예외 처리. 잘못된 입력에 대해 명확한 에러 메시지 반환.",
        "testStrategy": "유효하지 않은 파라미터로 API 호출 시 적절한 에러 코드 및 메시지가 반환되는지 테스트.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Isochrone 요청 파라미터 DTO 생성, DTO 필드에 유효성 검증 어노테이션 추가, 전역 예외 처리 핸들러 구현, 커스텀 Validator 구현 (좌표 형식, 이동수단), 그리고 좌표 및 시간 값의 논리적 범위 검증 추가 단계를 더 상세히 정의할 수 있습니다.",
        "subtasks": [
          {
            "id": 1,
            "title": "Pydantic 기반 IsochroneQuery 모델 정의",
            "description": "FastAPI 요청 파라미터를 Pydantic 모델로 묶어 재사용합니다.",
            "details": "schemas/isochrone.py 등에 IsochroneQuery 모델을 생성하고 from_place, cutoff_sec, mode, date, time 필드를 정의합니다. OTP가 요구하는 fromPlace/cutoffSec 키를 alias로 매핑하고 쿼리 파라미터 dict를 만들어내는 헬퍼를 제공합니다. 검증: FastAPI Docs에서 생성된 스키마를 확인하고 잘못된 타입 전달 시 422가 발생하는지 확인합니다.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "파라미터 제약 조건 및 기본값 정의",
            "description": "IsochroneQuery 필드에 범위/기본값 제약을 적용합니다.",
            "details": "from_place는 최소 길이, cutoff_sec은 양의 정수, mode는 허용된 문자열만 받도록 Literal/Enum을 사용합니다. date/time 필드는 ISO 포맷으로 직렬화되도록 처리하고 기본값(예: None)을 명확히 설정합니다. FastAPI Depends를 통해 기본 값을 제공해 문서화합니다. 검증: 잘못된 값 전송 시 422 응답에 명확한 에러 메시지가 포함되는지 확인합니다.}]},",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 3,
            "title": "FastAPI 예외 처리 및 에러 응답 통일",
            "description": "RequestValidationError, HTTPException, 커스텀 OTP 예외를 수집해 일관된 에러 바디를 반환합니다.",
            "details": "FastAPI의 exception_handler를 사용해 RequestValidationError와 OtpClientError를 가로채고 status, message, field_errors를 포함한 JSON을 반환합니다. 로깅을 추가하고 클라이언트로 전달할 safe 메시지와 내부 디버그 메시지를 구분합니다. 검증: pytest로 validation 실패/OTP 오류 시 응답 본문이 정의한 스키마와 일치하는지 검사합니다.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 4,
            "title": "좌표 및 이동수단 커스텀 검증",
            "description": "from_place 문자열과 mode 값에 대해 추가 검증 로직을 구현합니다.",
            "details": "Pydantic validator 또는 Annotated[constr]를 사용해 '위도,경도' 형식인지, 위경도 범위가 대한민국 영역(대략 위도 33~39, 경도 124~132)에 들어오는지 확인합니다. mode는 허용된 ENUM 집합(예: TRANSIT,WALK 등)만 통과시키고, 허용되지 않는 경우 사용자 친화적인 에러 메시지를 제공합니다. 검증: pytest parametrized 케이스로 잘못된 좌표/모드가 422 또는 400 응답으로 이어지는지 확인합니다.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 5,
            "title": "cutoffSec 및 시간 범위 검증",
            "description": "등시선 계산 시간과 요청 시각의 허용 범위를 제한합니다.",
            "details": "cutoff_sec 값에 Min/Max 제약(예: 최소 60초, 최대 10800초)을 두고, date/time 조합이 현재 날짜 기준 허용 범위를 벗어나면 사용자에게 안내합니다. 여러 cutoff 값을 허용한다면 리스트 항목마다 양의 정수인지 확인합니다. 검증: 허용 범위를 벗어난 값으로 호출 시 422 또는 400 응답과 명확한 메시지가 반환되는지 pytest로 확인합니다.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          }
        ]
      },
      {
        "id": 6,
        "title": "GeoJSON Polygon 응답 포맷 검증 및 최적화",
        "description": "Isochrone API의 GeoJSON Polygon 응답 구조를 검증하고, 필요시 포맷을 최적화합니다.",
        "details": "OTP에서 반환하는 GeoJSON 결과를 샘플링하여 좌표, 폴리곤 구조, 속성값 등이 표준 GeoJSON 스펙을 준수하는지 확인. 불필요한 속성 제거 및 응답 크기 최적화.",
        "testStrategy": "GeoJSON Linter 및 샘플 지도 시각화 도구(예: QGIS, Leaflet)로 응답 데이터 검증.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "OTP Isochrone API 샘플 응답 수집 및 분석",
            "description": "Task 4에서 구현된 API 엔드포인트에 실제 요청(예: 서울역 기준 30분, 60분 대중교통)을 보내, 반환되는 GeoJSON 응답의 전체 구조와 데이터를 수집합니다.",
            "dependencies": [],
            "details": "Postman 또는 curl을 사용하여 `/otp/routers/default/isochrone` 엔드포인트에 여러 `cutoffSec` 값으로 요청을 보냅니다. 반환된 JSON 응답을 파일로 저장하여 분석 준비를 합니다.",
            "status": "pending",
            "testStrategy": "API 호출이 성공(200 OK)하고, 유효한 JSON 형식의 응답을 받았는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "GeoJSON 응답의 표준(RFC 7946) 준수 여부 검증",
            "description": "수집된 샘플 응답이 GeoJSON 표준(RFC 7946)을 준수하는지 검증합니다. FeatureCollection, Feature, Geometry (Polygon/MultiPolygon), 좌표 순서 등을 확인합니다.",
            "dependencies": [
              1
            ],
            "details": "`geojson-lint`와 같은 온라인 도구나 라이브러리를 사용하여 수집된 GeoJSON 데이터의 유효성을 검사합니다. 오류나 경고가 발생하는 부분을 기록합니다.",
            "status": "pending",
            "testStrategy": "GeoJSON Linter 통과 여부를 확인하고, QGIS 또는 geojson.io와 같은 도구에서 에러 없이 시각화되는지 검증합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "응답 데이터 최적화를 위한 목표 GeoJSON 포맷 정의",
            "description": "원본 OTP 응답에서 불필요한 속성(properties)을 식별하고, 클라이언트에서 꼭 필요한 정보만 남긴 최적화된 GeoJSON Feature의 속성 구조를 정의합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "원본 속성 중 `time`, `distance` 등 핵심 정보 외의 불필요한 메타데이터를 제거 대상으로 선정합니다. 최종적으로 반환할 GeoJSON Feature의 `properties` 스키마를 문서화합니다.",
            "status": "pending",
            "testStrategy": "정의된 목표 포맷이 API 요구사항을 모두 만족시키는지 동료 검토(peer review)를 통해 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "원본 OTP 응답을 목표 포맷으로 변환하는 로직 구현",
            "description": "OTP 서버로부터 받은 원본 GeoJSON을 입력받아, 3번에서 정의한 목표 포맷으로 변환하는 중간 처리 로직(예: 프록시, 래퍼 함수)을 구현합니다.",
            "dependencies": [
              3
            ],
            "details": "Node.js 또는 Python 기반의 간단한 함수를 작성합니다. 이 함수는 GeoJSON 객체를 순회하며 `properties` 객체에서 불필요한 키-값 쌍을 제거하고, 필요한 경우 구조를 단순화합니다.",
            "status": "pending",
            "testStrategy": "단위 테스트를 작성하여, 샘플 원본 GeoJSON을 입력했을 때 예상되는 목표 포맷 GeoJSON이 정확히 출력되는지 검증합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "변환된 최종 GeoJSON 응답의 유효성 및 시각화 검증",
            "description": "4번에서 구현된 변환 로직을 거친 최종 GeoJSON 결과물이 여전히 유효한 표준을 따르는지, 그리고 지도 상에서 왜곡 없이 정상적으로 렌더링되는지 최종 검증합니다.",
            "dependencies": [
              4
            ],
            "details": "변환된 GeoJSON 파일을 geojson.io, QGIS 등의 도구에 로드하여 폴리곤 경계가 올바르게 표시되는지 확인합니다. 또한, `geojson-lint`로 다시 한번 표준 준수 여부를 검사합니다.",
            "status": "pending",
            "testStrategy": "여러 시간대(cutoffSec) 및 출발지(fromPlace)에 대해 생성된 최적화된 GeoJSON 파일들이 모두 지도 시각화 도구에서 에러 없이 렌더링되는지 확인합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "OTP Isochrone API 샘플 응답 수집 및 분석, GeoJSON 표준 준수 여부 검증, 응답 데이터 최적화를 위한 목표 포맷 정의, 원본 응답을 목표 포맷으로 변환하는 로직 구현, 그리고 변환된 최종 응답의 유효성 및 시각화 검증 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 7,
        "title": "API 성능 측정 및 기본 튜닝",
        "description": "Isochrone API의 응답시간, 메모리 사용량 등 성능을 측정하고, 기본적인 튜닝을 적용합니다.",
        "details": "JMeter, ab 등 벤치마크 도구로 다양한 파라미터(예: 강남 60분 기준)로 API 부하 테스트. OTP JVM 옵션, Docker 리소스 할당, 그래프 캐싱 등 기본 튜닝 적용.",
        "testStrategy": "성능 측정 결과가 PRD 기준(60분 isochrone 15-25초, 메모리 8-12GB) 내에 들어오는지 확인.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "성능 측정 환경 구축 및 벤치마크 시나리오 정의",
            "description": "API 성능 측정을 위한 JMeter 또는 Apache Benchmark(ab) 환경을 설정하고, 부하 테스트에 사용할 시나리오를 구체적으로 정의합니다.",
            "dependencies": [],
            "details": "JMeter를 설치하고 테스트 계획(Test Plan)을 생성합니다. 대상 API 엔드포인트는 '/otp/routers/default/isochrone'로 설정합니다. 주요 테스트 시나리오로 '강남역, 60분, 대중교통'과 '판교역, 30분, 도보' 등 대표적인 케이스를 포함하여 정의합니다.",
            "status": "pending",
            "testStrategy": "JMeter 또는 ab가 설치되고, 정의된 시나리오로 단일 요청을 보내 정상 응답을 받는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "초기(Baseline) 성능 벤치마크 실행 및 결과 수집",
            "description": "튜닝을 적용하기 전 현재 상태의 API 성능을 측정하여 기준 데이터를 확보합니다. 응답 시간, 처리량(TPS), 메모리 사용량, CPU 사용률을 기록합니다.",
            "dependencies": [
              1
            ],
            "details": "정의된 벤치마크 시나리오에 따라 10분 이상 부하 테스트를 실행합니다. JMeter의 Summary Report, Aggregate Graph 등을 통해 결과를 수집하고, `docker stats` 명령어로 컨테이너의 리소스 사용량을 모니터링하여 기록합니다.",
            "status": "pending",
            "testStrategy": "벤치마크 실행 후 결과 리포트 파일(JTL)이 생성되고, 응답 시간 및 리소스 사용량 데이터가 정상적으로 수집되었는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "OTP JVM 옵션 및 Docker 리소스 할당 튜닝",
            "description": "수집된 초기 성능 데이터를 바탕으로 OTP 서버의 JVM 힙 메모리 옵션과 Docker 컨테이너의 리소스 할당량을 조정합니다.",
            "dependencies": [
              2
            ],
            "details": "`docker-compose.yml` 파일 내 OTP 서비스의 `environment` 섹션에서 `JAVA_OPTS`를 수정하여 `-Xmx` (최대 힙 크기) 및 `-Xms` (초기 힙 크기) 값을 조정합니다. 예를 들어, `-Xmx10g -Xms10g` 와 같이 설정합니다. 또한 `deploy.resources.limits`를 사용하여 컨테이너의 CPU 및 메모리 제한을 설정합니다.",
            "status": "pending",
            "testStrategy": "수정된 `docker-compose.yml`로 컨테이너를 재시작한 후, `docker inspect` 명령어나 실행 중인 Java 프로세스 확인을 통해 JVM 옵션이 올바르게 적용되었는지 검증합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "OTP 그래프 캐싱 전략 적용",
            "description": "API 요청 시마다 그래프를 로딩하는 오버헤드를 줄이기 위해, 서버 시작 시점에 그래프를 미리 로드하여 메모리에 상주시키는 캐싱 전략을 적용합니다.",
            "dependencies": [
              2
            ],
            "details": "OTP 서버 실행 명령어에 `--load` 옵션을 명시하여 컨테이너 시작 시점에 그래프 파일(graph.obj)을 즉시 로드하도록 설정합니다. `docker-compose.yml`의 `command` 부분을 수정하여 이 옵션을 추가합니다. 이를 통해 첫 API 요청의 응답 지연을 최소화합니다.",
            "status": "pending",
            "testStrategy": "컨테이너 로그를 확인하여 OTP 서버 시작 시점에 'Graph data loaded.' 와 같은 로그가 출력되는지, 그리고 서버 기동 후 첫 API 요청의 응답 속도가 눈에 띄게 개선되었는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "튜닝 후 성능 재측정 및 결과 비교 분석",
            "description": "JVM, Docker, 캐싱 튜닝이 적용된 상태에서 동일한 시나리오로 벤치마크를 다시 실행하고, 초기 성능 데이터와 비교하여 개선 효과를 검증합니다.",
            "dependencies": [
              3,
              4
            ],
            "details": "초기 벤치마크와 동일한 조건(동일 시나리오, 동일 부하)에서 성능 테스트를 재실행합니다. 튜닝 전/후의 평균 응답 시간, 처리량, 메모리 사용량 변화를 비교 분석하는 보고서를 작성합니다. 목표 성능(60분 isochrone 15-25초, 메모리 8-12GB) 달성 여부를 확인합니다.",
            "status": "pending",
            "testStrategy": "최종 성능 측정 결과가 PRD에 명시된 목표치(응답시간 15-25초, 메모리 8-12GB) 범위 내에 들어오는지 확인하고, 초기 데이터 대비 최소 20% 이상의 성능 향상이 있었는지 검증합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "성능 측정 환경 구축 및 벤치마크 시나리오 정의, 초기 성능 벤치마크 실행 및 결과 수집, OTP JVM 옵션 및 Docker 리소스 할당 튜닝, OTP 그래프 캐싱 전략 적용, 그리고 튜닝 후 성능 재측정 및 결과 비교 분석 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 8,
        "title": "API 안정성 및 장애 대응 테스트",
        "description": "API의 외부 호출 성공률, 장애 상황(데이터 오류, 서버 다운 등)에서의 대응 방안을 검증합니다.",
        "details": "연속 호출, 경계값 입력, 데이터 누락 등 다양한 시나리오에서 API 성공률 측정. 장애 발생 시 로그 기록, 에러 응답, 자동 재시작 등 대응 로직 구현.",
        "testStrategy": "95% 이상 성공률 달성 여부 및 장애 상황에서의 복구/에러 응답 테스트.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "API 안정성 테스트 시나리오 및 성공 기준 정의",
            "description": "부하 테스트, 경계값 테스트, 장애 주입 테스트 등 구체적인 테스트 시나리오를 설계하고, 각 시나리오에 대한 성공 기준(응답 성공률, 응답 시간, 복구 시간 등)을 정량적으로 정의합니다.",
            "dependencies": [],
            "details": "문서(예: Markdown 파일)에 테스트 케이스 ID, 시나리오 설명, 요청 파라미터, 예상 결과, 성공 기준(예: 1000 RPM에서 99% 성공률)을 명시하여 테스트 계획을 수립합니다.",
            "status": "pending",
            "testStrategy": "수립된 테스트 계획이 태스크의 요구사항을 모두 포함하는지 동료 검토를 통해 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "API 부하 테스트 스크립트 개발 및 실행",
            "description": "정의된 시나리오에 따라 API에 연속적인 호출을 보내는 부하 테스트 스크립트를 작성합니다. 스크립트 실행 후 결과를 바탕으로 API 성공률과 평균 응답 시간을 측정합니다.",
            "dependencies": [
              1
            ],
            "details": "Python의 `requests`와 `asyncio` 또는 `k6`, `JMeter`와 같은 부하 테스트 도구를 사용하여 스크립트를 개발합니다. 스크립트는 분당 요청 수(RPM)를 파라미터로 조절할 수 있도록 구현합니다.",
            "status": "pending",
            "testStrategy": "개발된 스크립트가 정의된 부하 테스트 시나리오대로 동작하는지 확인하고, 측정된 성공률과 응답 시간이 성공 기준을 만족하는지 검증합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "예외 및 경계값 처리 테스트 스크립트 개발",
            "description": "유효하지 않은 좌표, 허용 범위를 벗어난 시간(cutoffSec), 지원하지 않는 이동수단, 필수 파라미터 누락 등 다양한 예외 및 경계값 케이스에 대한 테스트 자동화 스크립트를 작성합니다.",
            "dependencies": [
              1
            ],
            "details": "각 예외 케이스별로 API를 호출하고, 예상된 HTTP 상태 코드(예: 400 Bad Request)와 에러 메시지가 응답으로 반환되는지 검증하는 코드를 포함하여 스크립트를 작성합니다.",
            "status": "pending",
            "testStrategy": "모든 예외/경계값 테스트 케이스를 실행하여, API가 예상된 오류 코드와 메시지를 정확히 반환하는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "장애 감지를 위한 로깅 강화 및 Health Check 구현",
            "description": "장애 발생 시 원인 분석을 용이하게 하도록 OTP 서버의 로깅 레벨을 조정하고, Docker 컨테이너의 서비스 상태를 주기적으로 확인할 수 있는 Health Check를 구현합니다.",
            "dependencies": [],
            "details": "`docker-compose.yml` 파일의 OTP 서비스에 `logging` 드라이버 및 옵션을 설정하여 로그를 관리합니다. `healthcheck` 속성을 추가하여 isochrone 엔드포인트에 주기적으로 `curl` 요청을 보내고 정상 응답(HTTP 200)을 확인하도록 구성합니다.",
            "status": "pending",
            "testStrategy": "컨테이너 로그에 에러가 정상적으로 기록되는지 확인하고, `docker inspect` 명령을 통해 health check 상태가 'healthy'로 표시되는지 검증합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "컨테이너 자동 복구 정책 적용 및 장애 시나리오 검증",
            "description": "Docker 서비스가 예기치 않게 종료되었을 때 자동으로 재시작되도록 복구 정책을 설정하고, 실제 장애 상황을 시뮬레이션하여 자동 복구 기능이 정상 동작하는지 검증합니다.",
            "dependencies": [
              4
            ],
            "details": "`docker-compose.yml` 파일의 OTP 서비스에 `restart: unless-stopped` 정책을 추가합니다. `docker kill <container_id>` 명령으로 컨테이너를 강제 종료시킨 후, `docker ps`를 통해 컨테이너가 자동으로 재시작되고 health check가 다시 'healthy' 상태로 전환되는지 확인합니다.",
            "status": "pending",
            "testStrategy": "컨테이너를 수동으로 중지/종료시킨 후, 정의된 시간 내에 자동으로 재시작되어 서비스가 정상화되는지 반복적으로 테스트하여 검증합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "API 안정성 테스트 시나리오 및 성공 기준 정의, API 부하 테스트 스크립트 개발 및 실행, 예외 및 경계값 처리 테스트 스크립트 개발, 장애 감지를 위한 로깅 강화 및 Health Check 구현, 그리고 컨테이너 자동 복구 정책 적용 및 장애 시나리오 검증 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 9,
        "title": "API 사용 예시 및 문서화",
        "description": "Isochrone API의 사용법, 파라미터 설명, 샘플 요청/응답 예시를 README 및 별도 문서로 작성합니다.",
        "details": "README.md에 API 엔드포인트, 파라미터 설명, 샘플 curl 명령어, 응답 예시(GeoJSON) 등 문서화. 오류 코드 및 제한사항 명시.",
        "testStrategy": "문서만 보고 API를 호출할 수 있는지, 샘플 요청이 정상 동작하는지 검증.",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "README.md에 API 개요 및 엔드포인트 정보 추가",
            "description": "README.md 파일에 Isochrone API의 기능, 목적을 설명하는 개요 섹션을 추가하고, 기본 API 엔드포인트 URL을 명시합니다.",
            "dependencies": [],
            "details": "README.md 파일에 'API 사용법' 섹션을 생성하고, API가 어떤 문제를 해결하는지 간략히 설명합니다. `http://<your-server-address>/otp/routers/default/isochrone` 와 같은 형식으로 엔드포인트를 명시합니다.",
            "status": "pending",
            "testStrategy": "README.md 파일을 열어 개요 및 엔드포인트 정보가 명확하게 작성되었는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "API 요청 파라미터 상세 설명 작성",
            "description": "API 호출에 사용되는 모든 쿼리 파라미터(fromPlace, cutoffSec, mode 등)에 대한 상세 설명을 README.md에 표 형식으로 작성합니다.",
            "dependencies": [
              1
            ],
            "details": "각 파라미터에 대해 이름, 타입, 필수 여부, 설명, 예시 값을 포함하는 마크다운 테이블을 작성합니다. 예를 들어, `fromPlace`는 '위도,경도' 형식의 문자열이고 필수 항목임을 명시합니다.",
            "status": "pending",
            "testStrategy": "문서에 명시된 파라미터 설명이 실제 API 동작과 일치하는지, 예시 값이 유효한지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "샘플 API 요청 예시 (curl) 작성",
            "description": "사용자가 바로 복사해서 사용할 수 있는 완전한 `curl` 명령어 예시를 작성합니다. 실제 동작 가능한 파라미터 값들을 사용합니다.",
            "dependencies": [
              2
            ],
            "details": "서울 시내 특정 지점(예: 강남역)의 좌표와 일반적인 이동 시간(예: 3600초)을 파라미터로 사용하여 `curl` 명령어를 구성합니다. URL 인코딩이 필요한 경우 이를 명시합니다.",
            "status": "pending",
            "testStrategy": "README.md에 있는 `curl` 명령어를 터미널에서 직접 실행하여 API가 정상적으로 200 OK 응답을 반환하는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "샘플 API 응답 예시 (GeoJSON) 작성 및 추가",
            "description": "`curl` 예시 요청에 대한 실제 응답(GeoJSON 형식)을 README.md에 추가합니다. 가독성을 위해 일부 축약하거나 접을 수 있는 형태로 제공합니다.",
            "dependencies": [
              3
            ],
            "details": "3번 서브태스크의 `curl` 요청을 실행하여 얻은 GeoJSON 응답을 코드 블록으로 `README.md`에 추가합니다. 내용이 너무 길 경우, 주요 구조(type, features, geometry, properties)를 보여주고 좌표 배열은 일부만 표시합니다.",
            "status": "pending",
            "testStrategy": "문서에 포함된 GeoJSON 응답 예시가 유효한 GeoJSON 형식인지 linter로 검증하고, 구조가 실제 API 응답과 일치하는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "오류 코드 및 API 제한 사항 문서화",
            "description": "발생 가능한 주요 오류 케이스(예: 잘못된 파라미터)와 해당 HTTP 상태 코드 및 응답 메시지를 정리합니다. API의 성능적 제한 사항도 함께 명시합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "'오류 처리 및 제한 사항' 섹션을 추가합니다. 400 Bad Request(잘못된 좌표), 404 Not Found(경로 없음) 등의 케이스를 설명합니다. 또한, 최대 `cutoffSec` 값이나 동시 요청 수 제한과 같은 서비스 제약 조건을 명시합니다.",
            "status": "pending",
            "testStrategy": "문서에 설명된 오류를 유발하는 요청(예: 유효하지 않은 `fromPlace` 값 전송)을 보내고, 예상된 HTTP 상태 코드와 메시지가 반환되는지 확인합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "README.md에 API 개요 및 엔드포인트 정보 추가, API 요청 파라미터 상세 설명 작성, 샘플 API 요청 예시 (curl) 작성, 샘플 API 응답 예시 (GeoJSON) 작성 및 추가, 그리고 오류 코드 및 API 제한 사항 문서화 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 10,
        "title": "최종 POC 결과 보고서 작성 및 검증",
        "description": "POC 성공 기준(정상 동작, 성능, 안정성 등)에 대한 최종 결과 보고서 작성 및 검증.",
        "details": "API 정상 동작, 성능(응답시간, 메모리), 성공률 등 주요 지표를 정리하여 보고서 작성. 모든 테스트 케이스 결과 첨부.",
        "testStrategy": "보고서 내 모든 성공 기준이 충족되는지, 외부 검증자(PO 등) 확인 절차 포함.",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "POC 결과 보고서 목차 및 핵심 지표(KPI) 정의",
            "description": "보고서의 전체 구조를 설계하고, POC 성공 여부를 판단할 핵심 지표(정상 동작, 성능, 안정성)를 구체적으로 정의합니다.",
            "dependencies": [],
            "details": "보고서에 포함될 섹션(개요, 테스트 환경, 결과 요약, 상세 분석, 결론)을 확정합니다. 성능 지표(평균/95th 응답시간, 메모리 사용량), 안정성 지표(API 성공률, 에러율) 등 측정 기준을 명시합니다.",
            "status": "pending",
            "testStrategy": "정의된 목차와 KPI가 POC 목표를 모두 포함하는지 팀 내부 리뷰 및 PO 확인을 진행합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "성능 및 안정성 테스트 결과 데이터 수집 및 취합",
            "description": "이전에 수행한 API 성능 테스트(Task 7)와 안정성 테스트(Task 8)의 결과 데이터를 모두 수집하고 정리합니다.",
            "dependencies": [
              1
            ],
            "details": "부하 테스트 결과 로그(JMeter 등), 서버 모니터링(CPU, 메모리) 데이터, API 호출 성공/실패 로그를 취합하여 분석 가능한 형태로 가공합니다.",
            "status": "pending",
            "testStrategy": "수집된 데이터가 1번에서 정의된 KPI 항목들을 모두 측정할 수 있는지 확인하고, 누락된 데이터가 없는지 검토합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "결과 보고서 초안 작성 (데이터 분석 및 시각화 포함)",
            "description": "수집된 데이터를 기반으로 보고서의 본문을 작성합니다. 핵심 지표를 분석하고, 이해하기 쉬운 차트나 표로 시각화하여 포함시킵니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "정의된 목차에 따라 각 섹션을 채웁니다. 응답 시간 분포, 메모리 사용량 추이 등을 그래프로 시각화하고, 테스트 결과에 대한 분석 내용을 서술합니다.",
            "status": "pending",
            "testStrategy": "초안이 보고서 목차와 KPI 정의에 부합하는지, 데이터 해석에 오류가 없는지 동료 검토(peer review)를 진행합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "테스트 케이스 및 증빙 자료 취합 및 부록 작성",
            "description": "보고서의 결론을 뒷받침하는 모든 테스트 케이스의 상세 결과와 관련 로그, 스크린샷 등의 증빙 자료를 취합하여 부록으로 첨부합니다.",
            "dependencies": [
              3
            ],
            "details": "API 기능 테스트, 성능 테스트, 안정성 테스트 등 모든 테스트 시나리오와 실행 결과를 정리합니다. 원본 로그 파일이나 데이터는 별도 파일로 링크하여 첨부합니다.",
            "status": "pending",
            "testStrategy": "부록의 모든 자료가 보고서 본문의 내용과 일치하고, 제3자가 보고 내용을 검증할 수 있을 만큼 충분한지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "최종 보고서 검토, 승인 및 공유",
            "description": "작성 완료된 보고서 초안과 부록을 포함한 최종본을 관련 이해관계자(PO, 팀 리더 등)에게 공유하고, 검토 및 최종 승인을 받습니다.",
            "dependencies": [
              4
            ],
            "details": "검토 과정에서 발생한 피드백을 반영하여 보고서를 수정합니다. 최종 승인 후, 프로젝트 관리 도구(Confluence 등)나 지정된 저장소에 보고서를 업로드하여 공유합니다.",
            "status": "pending",
            "testStrategy": "PO 및 핵심 이해관계자로부터 보고서 내용에 대한 최종 승인(Sign-off)을 득합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "POC 결과 보고서 목차 및 핵심 지표 정의, 성능 및 안정성 테스트 결과 데이터 수집 및 취합, 결과 보고서 초안 작성 (데이터 분석 및 시각화 포함), 테스트 케이스 및 증빙 자료 취합 및 부록 작성, 그리고 최종 보고서 검토, 승인 및 공유 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 11,
        "title": "Isochrone 데모용 간단한 프런트엔드 구축",
        "description": "React/Vite 기반의 프런트엔드 애플리케이션을 `frontend` 디렉토리에 구축하여, 백엔드의 `/api/isochrone` 엔드포인트를 호출하고 결과를 텍스트로 시각화합니다.",
        "details": "Vite를 사용하여 `frontend` 디렉토리에 새로운 React(TypeScript) 프로젝트를 생성합니다 (`npm create vite@latest frontend -- --template react-ts`). API 요청 파라미터(`fromPlace`, `cutoffSec`, `mode` 등)를 입력받는 폼 컴포넌트를 구현하고, `useState` 훅으로 로딩/성공/에러 상태를 관리합니다. `axios` 또는 `fetch`를 사용하여 백엔드 API를 호출하는 클라이언트 로직을 작성합니다. 성공 시 응답으로 받은 GeoJSON 데이터를 `<pre>` 태그로 화면에 렌더링하고, GeoJSON을 파일로 다운로드하는 버튼을 추가합니다. 에러 발생 시 메시지를 표시합니다. 프로젝트 루트에 `.env` 파일을 생성하고 `VITE_API_BASE_URL=http://localhost:8080`과 같이 백엔드 URL을 환경 변수로 주입하며, 코드 내에서는 `import.meta.env.VITE_API_BASE_URL`로 참조합니다. 마지막으로, 최상위 `README.md` 파일에 'Frontend' 섹션을 추가하여 실행 방법(`npm install`, `npm run dev`)과 사용 예시를 문서화합니다.",
        "testStrategy": "1. `npm run dev` 명령어로 프런트엔드 개발 서버가 정상적으로 실행되는지 확인합니다.\n2. 입력 폼에 유효한 값(예: `fromPlace`: '37.5042,127.0245', `cutoffSec`: 1800)을 입력하고 요청 시 로딩 상태가 표시되는지 확인합니다.\n3. API 호출 성공 시, 백엔드로부터 받은 GeoJSON 응답이 텍스트 영역에 올바르게 표시되고 '다운로드' 버튼이 정상 동작하는지 검증합니다.\n4. 의도적으로 잘못된 파라미터를 입력하거나 백엔드 서버를 중지시킨 상태에서 API를 호출하여, 에러 메시지가 정상적으로 표시되는지 확인합니다.\n5. `.env` 파일의 `VITE_API_BASE_URL` 값을 변경했을 때, 프런트엔드가 변경된 URL로 API를 호출하는지 브라우저 개발자 도구의 네트워크 탭에서 확인합니다.",
        "status": "pending",
        "dependencies": [
          6
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "React/Vite 프로젝트 초기 설정 및 환경 구성",
            "description": "`frontend` 디렉토리에 Vite를 사용하여 새로운 React(TypeScript) 프로젝트를 생성하고, API 통신을 위한 `axios`를 설치합니다. 또한, 백엔드 API 주소를 관리하기 위한 환경 변수 파일을 생성하고, 버전 관리에서 제외되도록 `.gitignore`를 설정합니다.",
            "dependencies": [],
            "details": "1. 프로젝트 루트에서 `npm create vite@latest frontend -- --template react-ts` 명령어를 실행하여 `frontend` 디렉토리에 React/TS 프로젝트를 생성합니다.\n2. `cd frontend`로 이동한 후, `npm install axios`를 실행하여 HTTP 클라이언트를 설치합니다.\n3. 프로젝트 루트 디렉토리(최상위)에 `.env` 파일을 생성하고 `VITE_API_BASE_URL=http://localhost:8080` 내용을 추가합니다.\n4. 최상위 `.gitignore` 파일에 `frontend/node_modules`, `frontend/dist`, `.env*` 항목이 없다면 추가하여 버전 관리에서 제외시킵니다.",
            "status": "pending",
            "testStrategy": "1. `cd frontend` 후 `npm install` 및 `npm run dev` 명령어로 Vite 개발 서버가 정상적으로 실행되는지 확인합니다.\n2. `src/App.tsx` 파일 내에서 `console.log(import.meta.env.VITE_API_BASE_URL);` 코드를 추가하여 브라우저 콘솔에 `http://localhost:8080`이 출력되는지 확인합니다."
          },
          {
            "id": 2,
            "title": "API 요청 파라미터 입력 폼 컴포넌트 구현",
            "description": "사용자가 Isochrone 생성을 위해 필요한 파라미터(`fromPlace`, `cutoffSec`, `mode`)를 입력할 수 있는 UI 폼을 구현합니다. 각 입력 필드의 상태는 `useState` 훅을 사용하여 관리합니다.",
            "dependencies": [
              "11.1"
            ],
            "details": "1. `frontend/src/components` 디렉토리를 생성하고, `IsochroneForm.tsx` 파일을 만듭니다.\n2. `IsochroneForm.tsx` 내에 `fromPlace`(text), `cutoffSec`(number), `mode`(select: WALK, BICYCLE, TRANSIT)를 위한 `<input>` 및 `<select>` 태그를 포함하는 폼을 작성합니다.\n3. `App.tsx`에서 각 입력 필드에 대한 상태(e.g., `const [fromPlace, setFromPlace] = useState('37.5042,127.0245');`)를 `useState`로 정의하고, 이를 `IsochroneForm` 컴포넌트에 props로 전달하여 제어 컴포넌트로 구현합니다.\n4. 폼 제출(submit) 이벤트가 발생했을 때 호출될 함수를 props로 전달받도록 설계합니다.",
            "status": "pending",
            "testStrategy": "1. `npm run dev`로 앱을 실행하고, 폼이 화면에 올바르게 렌더링되는지 확인합니다.\n2. 각 입력 필드에 값을 입력하거나 변경했을 때, 컴포넌트의 상태가 정상적으로 업데이트되는지 React DevTools를 사용해 확인합니다.\n3. '요청' 버튼 클릭 시, 폼 제출 이벤트 핸들러가 정상적으로 호출되는지 `console.log`로 확인합니다."
          },
          {
            "id": 3,
            "title": "백엔드 API 호출 및 상태 관리 로직 작성",
            "description": "폼 제출 시 백엔드의 `/api/isochrone` 엔드포인트를 호출하는 비동기 함수를 작성합니다. API 요청의 생명주기(로딩, 성공, 에러)를 관리하기 위해 `useState` 훅을 사용하여 상태를 관리합니다.",
            "dependencies": [
              "11.1",
              "11.2"
            ],
            "details": "1. `App.tsx` 컴포넌트에 API 응답 데이터, 로딩 상태, 에러 상태를 관리할 `useState` 훅을 추가합니다. (e.g., `const [geojsonData, setGeojsonData] = useState(null);`, `const [isLoading, setIsLoading] = useState(false);`, `const [error, setError] = useState(null);`)\n2. 폼 제출 시 실행될 `handleFetchIsochrone` 함수를 비동기(async/await)로 작성합니다.\n3. 함수 내부에서 `setIsLoading(true)`로 로딩 상태를 시작하고, `try...catch` 블록을 사용합니다.\n4. `try` 블록에서 `axios.get` 또는 `fetch`를 사용하여 `import.meta.env.VITE_API_BASE_URL`과 `/api/isochrone` 경로를 조합하고, 폼 상태 값을 쿼리 파라미터로 전달하여 API를 호출합니다.\n5. 호출 성공 시, 응답 데이터를 `geojsonData` 상태에 저장하고, `catch` 블록에서는 발생한 에러를 `error` 상태에 저장합니다. `finally` 블록에서 `setIsLoading(false)`로 로딩 상태를 종료합니다.",
            "status": "pending",
            "testStrategy": "1. 백엔드 서버가 실행 중인 상태에서 폼을 제출했을 때, 브라우저의 네트워크 탭에서 `/api/isochrone` 요청이 정상적으로 전송되는지 확인합니다.\n2. 요청이 진행되는 동안 '로딩 중...'과 같은 메시지가 표시되는지 확인합니다.\n3. 의도적으로 백엔드 서버를 중지시키거나 잘못된 파라미터를 보내 API 요청이 실패했을 때, 에러 상태가 올바르게 설정되고 에러 메시지가 표시되는지 확인합니다."
          },
          {
            "id": 4,
            "title": "API 응답 결과 시각화 및 다운로드 기능 구현",
            "description": "API 호출이 성공했을 때, 응답으로 받은 GeoJSON 데이터를 화면에 텍스트 형태로 표시하고, 해당 데이터를 `.geojson` 파일로 다운로드할 수 있는 버튼을 구현합니다.",
            "dependencies": [
              "11.3"
            ],
            "details": "1. `App.tsx`의 JSX 영역에서 `geojsonData` 상태 값이 존재할 경우에만 `<pre>` 태그를 사용하여 `JSON.stringify(geojsonData, null, 2)` 결과를 렌더링하도록 조건부 렌더링을 추가합니다.\n2. `geojsonData`가 있을 때 'GeoJSON 다운로드' 버튼을 함께 표시합니다.\n3. 다운로드 버튼의 `onClick` 이벤트 핸들러 함수를 작성합니다. 이 함수는 `geojsonData`를 문자열로 변환한 후, `Blob` 객체를 생성하고, `URL.createObjectURL`을 사용하여 임시 URL을 만듭니다. 그 다음, `<a>` 태그를 동적으로 생성하여 `href`와 `download` 속성을 설정하고 클릭 이벤트를 발생시켜 파일 다운로드를 트리거합니다.",
            "status": "pending",
            "testStrategy": "1. API 요청 성공 후, 응답받은 GeoJSON 데이터가 `<pre>` 태그 안에 포맷에 맞게 예쁘게 출력되는지 확인합니다.\n2. 'GeoJSON 다운로드' 버튼을 클릭했을 때, `isochrone.geojson`과 같은 이름으로 파일이 정상적으로 다운로드되는지 확인합니다.\n3. 다운로드된 파일을 텍스트 편집기나 QGIS 같은 GIS 툴에서 열었을 때, 내용이 유효한 GeoJSON 형식인지 확인합니다."
          },
          {
            "id": 5,
            "title": "프로젝트 README 문서 업데이트",
            "description": "프로젝트의 최상위 `README.md` 파일에 'Frontend' 섹션을 추가하여, 프런트엔드 애플리케이션의 설치 방법, 실행 방법 및 간단한 사용 예시를 명확하게 문서화합니다.",
            "dependencies": [
              "11.1"
            ],
            "details": "1. 프로젝트 루트의 `README.md` 파일을 엽니다.\n2. '## Frontend' 섹션을 새로 추가합니다.\n3. 하위 섹션으로 '### 설치 (Installation)'와 '### 실행 (Running the dev server)'을 만듭니다.\n4. 설치 섹션에는 `cd frontend` 후 `npm install`을 실행하라는 안내를 작성합니다.\n5. 실행 섹션에는 `npm run dev` 명령어로 개발 서버를 시작하고, 브라우저에서 `http://localhost:5173` (또는 Vite가 지정한 포트)으로 접속하라는 안내를 작성합니다.\n6. 간단한 사용법(폼 입력 및 요청 버튼 클릭)에 대한 설명을 추가합니다.",
            "status": "pending",
            "testStrategy": "1. `README.md` 파일을 열어 'Frontend' 섹션이 명확하고 이해하기 쉽게 작성되었는지 검토합니다.\n2. 다른 팀원이 문서를 보고 프런트엔드 애플리케이션을 독립적으로 설치하고 실행할 수 있는지 확인합니다."
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-12T17:38:06.306Z",
      "taskCount": 10,
      "completedCount": 1,
      "tags": [
        "master"
      ],
      "created": "2025-11-15T08:57:00.336Z",
      "description": "Tasks for master context",
      "updated": "2025-11-21T06:05:12.766Z"
    }
  }
}