{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "OTP 환경 및 프로젝트 초기화",
        "description": "OpenTripPlanner(OTP) 2.2+ 환경을 Java 21 및 Docker 기반으로 초기화하고, 프로젝트 구조를 세팅합니다.",
        "details": "Dockerfile을 작성하여 Java 21 기반 OTP 이미지를 빌드합니다. 프로젝트 루트에 docker-compose.yml을 생성하여 OTP 서버 컨테이너를 정의합니다. OTP 공식 문서에 따라 환경변수 및 볼륨 마운트 경로를 설정합니다.",
        "testStrategy": "Docker 컨테이너 실행 후 OTP 서버가 정상적으로 기동되는지, /otp/routers/default/health 엔드포인트에서 상태 확인.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Java 21 및 OTP 기반 Dockerfile 작성",
            "description": "OpenTripPlanner(OTP) 2.2+ 버전을 실행하기 위한 Java 21 환경의 Dockerfile을 정의합니다. OTP JAR 파일을 다운로드하고 실행 가능한 환경을 구성합니다.",
            "dependencies": [],
            "details": "공식 `eclipse-temurin:21-jre-jammy` 이미지를 기반으로 Dockerfile을 작성합니다. `ARG`를 사용하여 OTP 버전을 동적으로 지정하고, `wget` 또는 `curl`을 사용하여 Maven Central에서 지정된 버전의 OTP JAR 파일을 다운로드합니다.",
            "status": "done",
            "testStrategy": "`docker build . -t otp-server` 명령어를 실행하여 이미지가 오류 없이 성공적으로 빌드되는지 확인합니다.",
            "updatedAt": "2025-10-12T17:20:04.317Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "OTP 데이터 및 설정용 디렉토리 구조 생성",
            "description": "OTP의 그래프 데이터(GTFS, OSM)와 설정 파일을 관리하기 위한 호스트 머신의 디렉토리 구조를 생성합니다. 이 구조는 Docker 컨테이너에 볼륨으로 마운트됩니다.",
            "dependencies": [],
            "details": "프로젝트 루트에 `otp_data` 디렉토리를 생성하고, 그 하위에 `graphs/default`, `gtfs`, `osm` 디렉토리를 순차적으로 생성합니다. `graphs/default` 디렉토리는 OTP가 빌드한 그래프 파일과 설정 파일을 저장하는 데 사용됩니다.",
            "status": "done",
            "testStrategy": "`ls -R otp_data` 명령어를 실행하여 `otp_data/graphs/default`, `otp_data/gtfs`, `otp_data/osm` 디렉토리 구조가 올바르게 생성되었는지 확인합니다.",
            "parentId": "undefined",
            "updatedAt": "2025-10-12T17:20:23.664Z"
          },
          {
            "id": 3,
            "title": "OTP 서버 및 그래프 빌드 기본 설정 파일 생성",
            "description": "OTP 서버의 기본 동작을 정의하는 `otp-config.json`과 그래프 데이터 빌드 설정을 위한 `build-config.json`의 초기 템플릿 파일을 생성합니다.",
            "dependencies": [
              2
            ],
            "details": "`otp_data/graphs/default` 디렉토리 내에 비어 있거나 최소한의 설정만 포함된 `build-config.json`과 `otp-config.json` 파일을 생성합니다. `otp-config.json`에는 라우터 설정(`routingDefaults`)과 같은 기본 구조를 포함시킵니다.",
            "status": "done",
            "testStrategy": "생성된 JSON 파일들이 유효한 형식인지 `jq . otp_data/graphs/default/*.json`과 같은 JSON 파싱 도구를 사용하여 검증합니다.",
            "parentId": "undefined",
            "updatedAt": "2025-10-12T17:23:39.788Z"
          },
          {
            "id": 4,
            "title": "Docker Compose를 이용한 OTP 서비스 정의",
            "description": "OTP 서버 컨테이너를 쉽게 실행하고 관리할 수 있도록 `docker-compose.yml` 파일을 작성합니다. 포트 매핑, 볼륨 마운트, 환경 변수 설정을 포함합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "프로젝트 루트에 `docker-compose.yml` 파일을 생성합니다. Subtask 1에서 작성한 Dockerfile을 `build` 컨텍스트로 지정합니다. `8080:8080` 포트를 매핑하고, `otp_data` 디렉토리를 컨테이너의 `/var/otp` 경로에 마운트합니다. `JAVA_OPTS` 환경 변수를 사용하여 OTP 서버의 힙 메모리(-Xmx, -Xms)를 설정합니다.",
            "status": "done",
            "testStrategy": "`docker-compose config` 명령어를 실행하여 `docker-compose.yml` 파일의 구문이 유효하고 설정이 올바르게 로드되는지 확인합니다.",
            "parentId": "undefined",
            "updatedAt": "2025-10-12T17:27:26.616Z"
          },
          {
            "id": 5,
            "title": "OTP 컨테이너 초기 실행 및 상태 확인",
            "description": "작성된 `docker-compose.yml`을 사용하여 OTP 컨테이너를 실행하고, 서버 애플리케이션이 정상적으로 기동되는지 기본 엔드포인트를 통해 확인합니다.",
            "dependencies": [
              3,
              4
            ],
            "details": "`docker-compose up` 명령어를 사용하여 OTP 컨테이너를 실행합니다. 컨테이너 로그를 확인하여 JVM 관련 에러 없이 서버가 시작되는지 확인합니다. `curl http://localhost:8080/otp`를 호출하여 OTP 관련 응답(예: 404 Not Found, 라우터가 없다는 메시지)이 수신되는지 확인하여 서비스 기동을 검증합니다.",
            "status": "done",
            "testStrategy": "`docker-compose ps` 명령으로 컨테이너가 'Up' 상태인지 확인하고, `curl -I http://localhost:8080/otp`를 통해 HTTP 응답 코드를 확인하여 서비스가 실행 중인지 검증합니다.",
            "parentId": "undefined",
            "updatedAt": "2025-10-12T17:38:06.305Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "OTP 환경 초기화를 위한 Dockerfile 및 docker-compose.yml 작성, 볼륨 마운트 설정, 초기 OTP 설정 파일 생성, 그리고 서비스 기동 및 헬스체크 확인 단계를 더 상세히 정의할 수 있습니다.",
        "updatedAt": "2025-10-12T17:38:06.305Z"
      },
      {
        "id": 2,
        "title": "한국 GTFS 및 OSM 데이터 수집 및 검증",
        "description": "한국 대중교통 GTFS 데이터와 OpenStreetMap(OSM) 데이터를 수집하고, OTP에서 요구하는 포맷으로 검증합니다.",
        "details": "GTFS 데이터는 국토교통부 또는 서울 열린데이터광장 등에서 최신 버전을 다운로드합니다. OSM 데이터는 Geofabrik 등에서 서울/한국 지역을 추출합니다. 데이터 무결성 및 포맷(경로, 정류장, 일정 등) 검증 스크립트 작성.",
        "testStrategy": "GTFS 및 OSM 파일을 OTP에 로드하여 오류 메시지 없이 그래프 빌드가 가능한지 확인.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "한국 GTFS 데이터 소스 조사 및 다운로드",
            "description": "최신 한국 대중교통 GTFS 데이터를 제공하는 공식 소스(예: 서울시 열린데이터광장, 국토교통부)를 조사하고, 최신 버전의 데이터를 다운로드합니다.",
            "dependencies": [],
            "details": "서울시 열린데이터광장 또는 국가대중교통정보센터(TAGO) 포털을 방문하여 수도권 GTFS 데이터셋을 찾습니다. 다운로드 URL을 기록하고, `gtfs.zip` 파일을 로컬에 저장합니다.",
            "status": "done",
            "testStrategy": "다운로드한 zip 파일의 압축을 해제하여 'stops.txt', 'routes.txt', 'trips.txt' 등 필수 파일이 포함되어 있는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "한국 지역 OSM 데이터 추출 및 다운로드",
            "description": "OpenTripPlanner에 필요한 도로망 데이터를 위해 한국 지역의 OpenStreetMap(OSM) 데이터를 다운로드합니다.",
            "dependencies": [],
            "details": "Geofabrik (download.geofabrik.de)에서 한국(South Korea) 지역의 최신 OSM 데이터를 '.pbf' 형식으로 다운로드합니다. 파일 이름은 'korea-latest.osm.pbf'와 같은 명확한 이름으로 저장합니다.",
            "status": "done",
            "testStrategy": "다운로드한 '.pbf' 파일의 크기가 비정상적으로 작지 않은지 (최소 수백 MB 이상) 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "OTP 프로젝트 데이터 디렉토리 구성",
            "description": "다운로드한 GTFS 및 OSM 데이터를 OTP가 인식할 수 있는 프로젝트 내 특정 디렉토리에 배치합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "프로젝트 루트의 'data' 디렉토리에 다운로드한 GTFS zip 파일과 OSM .pbf 파일을 이동시킵니다. 이 경로는 'docker-compose.yml'에 정의된 OTP 컨테이너의 볼륨 마운트 경로와 일치해야 합니다.",
            "status": "done",
            "testStrategy": "`ls -l data/` 명령어를 실행하여 GTFS와 OSM 파일이 모두 존재하는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "OTP를 이용한 데이터 유효성 검증 및 초기 그래프 빌드",
            "description": "준비된 GTFS 및 OSM 데이터를 사용하여 OpenTripPlanner 서버를 실행하고, 데이터 로딩 및 그래프 빌드 과정에서 오류가 없는지 확인합니다.",
            "dependencies": [
              3
            ],
            "details": "프로젝트 루트에서 `docker-compose up` 명령을 실행하여 OTP 컨테이너를 시작합니다. 컨테이너 로그를 실시간으로 모니터링하며 데이터 파싱 과정과 그래프 빌드 완료 메시지를 확인합니다.",
            "status": "done",
            "testStrategy": "OTP 서버 로그에서 심각한(SEVERE) 오류나 예외 없이 'Grizzly server running' 및 그래프 빌드 관련 로그가 정상적으로 출력되는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "데이터 수집 자동화 쉘 스크립트 작성",
            "description": "향후 데이터 업데이트를 용이하게 하기 위해, GTFS 및 OSM 데이터를 자동으로 다운로드하여 'data' 디렉토리에 배치하는 쉘 스크립트를 작성합니다.",
            "dependencies": [
              1,
              2,
              4
            ],
            "details": "'scripts/download_data.sh' 파일을 생성합니다. `curl` 또는 `wget` 명령어를 사용하여 1, 2번 태스크에서 확정한 URL로부터 데이터를 다운로드하고 'data' 디렉토리에 저장합니다. 스크립트에 실행 권한(`chmod +x`)을 부여합니다.",
            "status": "done",
            "testStrategy": "기존 'data' 디렉토리를 비운 후 `./scripts/download_data.sh` 스크립트를 실행하여 GTFS 및 OSM 파일이 정상적으로 다운로드되는지 확인합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "한국 GTFS 및 OSM 데이터 소스 조사 및 다운로드, 프로젝트 디렉토리 구성, OTP를 이용한 초기 데이터 유효성 검증, 그리고 데이터 수집 자동화 스크립트 개발 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 3,
        "title": "OTP 그래프 빌드 및 데이터 통합 자동화",
        "description": "수집한 GTFS/OSM 데이터를 기반으로 OTP 그래프 빌드 프로세스를 자동화합니다.",
        "details": "Docker 컨테이너 내에서 GTFS/OSM 데이터를 지정 경로에 배치하고, OTP의 graph-builder 명령어를 통해 그래프를 생성하는 스크립트 작성. 빌드 결과물(graph.obj 등)을 서버 실행에 활용.",
        "testStrategy": "그래프 빌드 완료 후, OTP 서버에서 경로 탐색 및 isochrone API 호출이 정상적으로 동작하는지 확인.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "GTFS/OSM 데이터 컨테이너 내 경로 설정 및 검증",
            "description": "OTP 그래프 빌더가 GTFS 및 OSM 데이터를 읽을 수 있도록 Docker 컨테이너 내 파일 시스템 경로를 정의하고, Task 2에서 수집된 데이터가 해당 경로로 정상적으로 마운트/복사되는지 확인합니다. docker-compose.yml의 볼륨 설정을 검토하고 필요시 수정합니다.",
            "dependencies": [],
            "details": "`docker-compose.yml`에서 OTP 컨테이너 내부에 `/otp/graphs/default/data/gtfs` 및 `/otp/graphs/default/data/osm`와 같은 경로에 호스트의 데이터 디렉토리를 마운트하도록 설정합니다. `docker exec` 명령어를 사용하여 컨테이너 내부에서 데이터 파일 접근 가능 여부를 확인합니다.",
            "status": "done",
            "testStrategy": "컨테이너가 실행 중인 상태에서 `docker exec <container_id> ls -l /otp/graphs/default/data/gtfs` 명령어를 실행하여 GTFS 파일 목록이 정상적으로 표시되는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "OTP 그래프 빌드 쉘 스크립트 개발",
            "description": "OTP의 graph-builder 기능을 활용하여 GTFS 및 OSM 데이터를 기반으로 교통 그래프를 빌드하는 쉘 스크립트(예: `build_graph.sh`)를 작성합니다. 이 스크립트는 OTP 실행 환경 설정 및 빌드 명령어를 포함해야 합니다.",
            "dependencies": [
              1
            ],
            "details": "`otp-2.2.0-shaded.jar` 파일을 실행하며 `build --basePath /otp --router default --graphPath /otp/graphs/default/ --in/gtfs /otp/graphs/default/data/gtfs --in/osm /otp/graphs/default/data/osm`와 유사한 명령어를 사용합니다. 빌드 중 메모리 부족을 방지하기 위해 `JAVA_OPTS` 환경변수에 `\"-Xmx4G\"` 등을 설정하여 스크립트에 포함합니다.",
            "status": "done",
            "testStrategy": "작성된 스크립트를 수동으로 실행하여 그래프 빌드가 성공적으로 완료되고, 지정된 출력 경로(예: `/otp/graphs/default/`)에 `graph.obj` 파일이 생성되는지 확인합니다. 빌드 로그에 에러가 없는지 검토합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Docker Compose 그래프 빌드 서비스 통합",
            "description": "작성된 그래프 빌드 쉘 스크립트를 실행하는 별도의 Docker Compose 서비스를 `docker-compose.yml`에 추가합니다. 이 서비스는 GTFS/OSM 데이터 볼륨과 빌드 결과물 저장용 볼륨에 접근할 수 있도록 설정해야 합니다.",
            "dependencies": [
              2
            ],
            "details": "`docker-compose.yml`에 `graph-builder` 또는 `otp-builder`라는 이름의 서비스를 추가하고, `command` 필드에 `build_graph.sh` 스크립트 실행 명령어를 지정합니다. `volumes` 설정을 통해 GTFS/OSM 데이터 볼륨과 빌드된 `graph.obj` 파일이 저장될 영구 볼륨을 공유하도록 구성합니다.",
            "status": "done",
            "testStrategy": "`docker-compose up otp-builder` 명령어를 실행하여 빌드 서비스가 성공적으로 그래프를 생성하고 종료되는지 확인합니다. 이후 해당 볼륨 마운트 경로에 `graph.obj` 파일이 정상적으로 생성 및 저장되었는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "OTP 서버용 빌드된 그래프 로드 설정",
            "description": "Docker Compose 내 OTP 서버 서비스가 이전에 `graph-builder` 서비스에 의해 생성된 `graph.obj` 파일을 자동으로 로드하도록 설정합니다. OTP 서버의 설정 파일을 업데이트하거나 서버 시작 명령을 조정하여 그래프 파일 경로를 지정합니다.",
            "dependencies": [
              3
            ],
            "details": "OTP 서버 서비스의 `command` 또는 환경변수를 통해 `graph.obj` 파일이 위치한 경로(예: `/otp/graphs/default/graph.obj`)를 지정하여 서버 시작 시 로드되도록 합니다. `router-config.json`에 `graphPath`를 설정하거나, OTP 서버 시작 명령에 `--graph /path/to/graph.obj` 옵션을 추가합니다.",
            "status": "done",
            "testStrategy": "`docker-compose up otp-server` (또는 전체 `docker-compose up`) 실행 후, OTP 서버 컨테이너의 로그에서 `graph.obj` 파일 로딩 관련 메시지(예: \"Graph loaded successfully\")를 확인하여 그래프 로드 성공 여부를 검증합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "전체 빌드 및 서버 실행 워크플로우 자동화 검증",
            "description": "데이터 준비부터 그래프 빌드, 그리고 빌드된 그래프를 사용하는 OTP 서버 실행까지의 전체 자동화 워크플로우를 엔드투엔드로 검증합니다. 모든 과정이 스크립트와 Docker Compose만으로 자동 실행되고 성공적으로 완료되는지 확인합니다.",
            "dependencies": [
              4
            ],
            "details": "`docker-compose down -v` 명령어로 모든 볼륨을 제거한 후, `docker-compose up --build -d` 명령어를 통해 모든 과정을 초기부터 실행합니다. OTP 서버가 완전히 기동된 후, `/otp/routers/default/health` 엔드포인트에 접속하여 상태를 확인하고, 간단한 경로 탐색 (예: `http://localhost:8080/otp/routers/default/plan?fromPlace=37.5,127.0&toPlace=37.6,127.1`) 또는 isochrone API를 호출하여 그래프가 정상 작동하는지 확인합니다.",
            "status": "done",
            "testStrategy": "OTP 서버의 health check 엔드포인트가 `{\"status\":\"OK\"}`를 반환하는지 확인하고, 실제 경로 탐색 API 호출이 유효한 계획 응답(예: 경로 정보, 시간 등)을 반환하는지 검증합니다. 빌드 및 서버 기동 과정에서 발생하는 모든 로그를 검토하여 에러가 없는지 확인합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "GTFS/OSM 데이터 컨테이너 내 경로 설정 및 검증, OTP 그래프 빌드 쉘 스크립트 개발, Docker Compose 빌드 서비스 통합, 빌드된 그래프 로드 설정, 그리고 전체 워크플로우 자동화 검증 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 4,
        "title": "Isochrone REST API 엔드포인트 구현",
        "description": "OTP 내장 REST API(/otp/routers/default/isochrone) 엔드포인트를 외부에서 호출할 수 있도록 설정 및 문서화합니다.",
        "details": "OTP의 isochrone API 엔드포인트를 활성화하고, 필요한 쿼리 파라미터(fromPlace, cutoffSec, mode 등)를 명확히 문서화합니다. Docker 네트워크 및 포트 설정을 통해 외부 접근 허용.",
        "testStrategy": "curl 또는 Postman으로 /isochrone 엔드포인트에 요청하여 GeoJSON Polygon 응답이 정상적으로 반환되는지 확인.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "docker-compose.yml OTP 서비스 포트(8080) 노출 설정",
            "description": "docker-compose.yml 파일에서 주석 처리된 'ports' 설정을 활성화하여 OTP 컨테이너의 8080 포트를 호스트 머신에 바인딩합니다. 이를 통해 외부에서 OTP API에 접근할 수 있는 기본 통로를 마련합니다.",
            "dependencies": [],
            "details": "docker-compose.yml 파일의 otp 서비스 정의에서 'ports: - \"8080:8080\"' 라인의 주석을 제거하고 'docker-compose up -d --build' 명령어로 서비스를 재시작합니다.",
            "status": "pending",
            "testStrategy": "`docker ps` 명령어를 실행하여 otp 컨테이너의 PORTS 항목에 '0.0.0.0:8080->8080/tcp'와 같이 포트 포워딩이 정상적으로 설정되었는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Docker 컨테이너 내부에서 Isochrone API 동작 검증",
            "description": "`docker exec`를 사용하여 실행 중인 OTP 컨테이너에 접속한 후, `curl` 명령어로 `localhost:8080`의 isochrone 엔드포인트가 정상적으로 응답하는지 확인합니다. 이는 네트워크 문제가 아닌 OTP 애플리케이션 자체의 동작을 검증하기 위함입니다.",
            "dependencies": [
              1
            ],
            "details": "`docker exec -it <otp_container_name> /bin/bash` 명령어로 컨테이너에 접속한 후, `curl \"http://localhost:8080/otp/routers/default/isochrone?fromPlace=37.5665,126.9780&mode=WALK&cutoffSec=600\"` 와 같은 명령어로 API 응답을 확인합니다.",
            "status": "pending",
            "testStrategy": "curl 요청 시 HTTP 200 OK 상태 코드와 함께 GeoJSON 형식의 응답 본문(geometry type: Polygon)이 반환되는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Nginx 리버스 프록시를 이용한 API 엔드포인트 구성",
            "description": "외부 요청(`/api/isochrone`)을 내부 OTP 서비스(`/otp/routers/default/isochrone`)로 전달하는 Nginx 리버스 프록시를 설정합니다. 이를 위해 `docker-compose.yml`에 Nginx 서비스를 추가하고 관련 설정 파일을 작성합니다.",
            "dependencies": [
              1
            ],
            "details": "`nginx/default.conf` 파일을 생성하고 `location /api/isochrone { ... }` 블록 내에 `proxy_pass http://otp:8080/otp/routers/default/isochrone;` 설정을 추가합니다. `docker-compose.yml`에 nginx 서비스를 정의하고 호스트의 80 포트와 연결합니다.",
            "status": "pending",
            "testStrategy": "Nginx 컨테이너 로그를 확인하여 `/api/isochrone` 요청이 `http://otp:8080/...`으로 정상적으로 프록시 패스되는지 검증합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Isochrone API 명세서 작성 (요청 파라미터 및 응답)",
            "description": "API 사용에 필요한 필수 및 선택 쿼리 파라미터(fromPlace, cutoffSec, mode, date, time 등)를 정의하고, 각 파라미터의 형식과 예시를 포함한 문서를 작성합니다. 또한, 성공 시 반환되는 GeoJSON 응답의 구조를 설명합니다.",
            "dependencies": [
              2
            ],
            "details": "README.md 파일에 'API Usage' 섹션을 추가하여 엔드포인트 URL, HTTP 메서드, 각 쿼리 파라미터의 설명, 데이터 타입, 필수 여부를 표 형식으로 정리합니다. Postman 또는 curl을 사용한 요청 예시와 샘플 응답 GeoJSON을 포함합니다.",
            "status": "pending",
            "testStrategy": "작성된 문서의 샘플 요청(curl)을 복사하여 터미널에서 실행했을 때, 문서에 명시된 샘플 응답과 동일한 구조의 결과가 반환되는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "외부에서 Nginx를 통한 End-to-End Isochrone API 호출 테스트",
            "description": "호스트 머신이나 Postman과 같은 외부 클라이언트에서 Nginx가 노출하는 엔드포인트(예: `http://localhost/api/isochrone`)를 호출하여 전체 API 요청-응답 흐름이 정상적으로 동작하는지 최종 검증합니다.",
            "dependencies": [
              3,
              4
            ],
            "details": "Postman 또는 curl을 사용하여 `http://localhost/api/isochrone?fromPlace=37.5665,126.9780&mode=TRANSIT&cutoffSec=1800` 와 같은 실제 사용 예시 요청을 보내고, 유효한 GeoJSON 폴리곤이 반환되는지 확인합니다.",
            "status": "pending",
            "testStrategy": "다양한 `cutoffSec` 및 `mode` 파라미터 값으로 API를 요청하고, 예상되는 구조의 GeoJSON 응답이 정상적으로 수신되는지 확인합니다. 또한, 잘못된 파라미터로 요청 시 적절한 HTTP 오류 코드가 반환되는지 확인합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Docker Compose에서 OTP 서비스 포트 노출 설정, 컨테이너 내 Isochrone API 동작 검증, Nginx 리버스 프록시 구성, API 명세서 작성, 그리고 외부에서의 End-to-End API 호출 테스트 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 5,
        "title": "API 파라미터 검증 및 입력 유효성 처리",
        "description": "API 요청 시 입력되는 파라미터(좌표, 시간, 이동수단 등)의 유효성 검증 로직을 구현합니다.",
        "details": "REST API 호출 시 필수 파라미터 누락, 범위 오류, 지원하지 않는 이동수단 등 예외 처리. 잘못된 입력에 대해 명확한 에러 메시지 반환.",
        "testStrategy": "유효하지 않은 파라미터로 API 호출 시 적절한 에러 코드 및 메시지가 반환되는지 테스트.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Isochrone 요청 파라미터를 위한 DTO(Data Transfer Object) 생성",
            "description": "API 요청 파라미터(fromPlace, cutoffSec, mode 등)를 개별 `@RequestParam` 대신 하나의 DTO 객체로 묶어 관리합니다. 이를 통해 향후 유효성 검증 및 파라미터 확장이 용이해집니다.",
            "dependencies": [],
            "details": "`IsochroneRequestDto.java` 클래스를 생성하고 `fromPlace`, `cutoffSec`, `mode` 등의 필드를 정의합니다. 기존 `IsochroneController`의 API 메소드 시그니처를 `@RequestBody IsochroneRequestDto`를 인자로 받도록 수정합니다.",
            "status": "pending",
            "testStrategy": "정상적인 파라미터를 담은 JSON 본문으로 API 요청 시, DTO 객체가 올바르게 매핑되어 기존과 동일하게 성공 응답이 반환되는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "DTO 필드에 기본 유효성 검증 어노테이션 추가",
            "description": "`spring-boot-starter-validation` 의존성을 추가하고, DTO의 각 필드에 JSR-380 표준 어노테이션을 사용하여 필수값, 빈 값 여부 등 기본적인 제약 조건을 설정합니다.",
            "dependencies": [
              1
            ],
            "details": "`build.gradle` 또는 `pom.xml`에 `spring-boot-starter-validation` 의존성을 추가합니다. `IsochroneRequestDto`의 `fromPlace`, `mode` 필드에 `@NotBlank`, `cutoffSec` 필드에 `@NotEmpty` 어노테이션을 추가하고, 컨트롤러 메소드의 DTO 파라미터에 `@Valid` 어노테이션을 추가하여 검증을 활성화합니다.",
            "status": "pending",
            "testStrategy": "필수 파라미터(예: fromPlace)를 누락시키거나 빈 문자열로 요청했을 때, HTTP 400 Bad Request 상태 코드와 함께 오류 응답이 반환되는지 테스트합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "전역 예외 처리 핸들러 구현",
            "description": "유효성 검증 실패 시 발생하는 `MethodArgumentNotValidException`을 처리하기 위한 전역 예외 핸들러를 구현합니다. 이를 통해 모든 API에서 일관된 형식의 에러 메시지를 반환할 수 있습니다.",
            "dependencies": [
              2
            ],
            "details": "`@ControllerAdvice` 어노테이션을 사용한 `GlobalExceptionHandler` 클래스를 생성합니다. `@ExceptionHandler(MethodArgumentNotValidException.class)` 메소드를 정의하여, 예외 객체에서 오류 정보를 추출하고 표준화된 에러 응답 DTO(예: `ErrorResponse`)에 담아 반환하도록 구현합니다. 응답 형식에는 상태 코드, 에러 메시지, 상세 필드 오류 목록이 포함되어야 합니다.",
            "status": "pending",
            "testStrategy": "2번 테스트 케이스(필수 파라미터 누락) 실행 시, 응답 본문이 여기서 정의한 표준 에러 형식(예: `{\"status\": 400, \"message\": \"입력값이 올바르지 않습니다.\", \"errors\": [{\"field\": \"fromPlace\", \"reason\": \"반드시 값이 있어야 합니다.\"}]}`)에 맞게 반환되는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "좌표 형식 및 이동수단 검증을 위한 커스텀 Validator 구현",
            "description": "`fromPlace` 파라미터가 \"위도,경도\" 형식인지, `mode` 파라미터가 지원되는 이동수단(예: WALK, TRANSIT) 중 하나인지 검증하는 커스텀 유효성 검증 로직을 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "좌표 형식 검증을 위해 `@Coordinate` 커스텀 어노테이션과 `CoordinateValidator` 클래스를 구현합니다. Validator 내에서 정규식을 사용하여 \"숫자,숫자\" 형식을 확인합니다. 이동수단은 `String` 타입 대신 `TransportMode` enum 타입을 사용하도록 DTO를 변경하여, 허용되지 않은 문자열이 입력될 경우 Jackson 레벨에서 `InvalidFormatException`이 발생하도록 유도합니다.",
            "status": "pending",
            "testStrategy": "잘못된 좌표 형식(예: \"37.5, 127.0, 1.0\" 또는 \"서울\")이나 지원되지 않는 이동수단(예: \"CAR\")으로 요청 시, HTTP 400 에러와 함께 명확한 오류 메시지가 반환되는지 테스트합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "좌표 및 시간 값의 논리적 범위 검증 추가",
            "description": "입력된 좌표 값이 실제 대한민국 영토 내에 위치하는지, 그리고 등시선 계산 시간(`cutoffSec`)이 시스템에서 허용하는 합리적인 범위 내에 있는지 검증합니다.",
            "dependencies": [
              4
            ],
            "details": "`CoordinateValidator`에 대한민국 위경도 범위(대략 위도 33~39, 경도 124~132)를 체크하는 로직을 추가합니다. `IsochroneRequestDto`의 `cutoffSec` 필드의 각 원소에 `@Min(60)`(최소 1분), `@Max(10800)`(최대 3시간) 등의 어노테이션을 추가하여 입력 가능한 시간 범위를 제한합니다.",
            "status": "pending",
            "testStrategy": "대한민국 범위를 벗어나는 좌표(예: \"0.0,0.0\")나 허용 범위를 벗어나는 시간(예: 30초 또는 4시간)으로 요청 시, HTTP 400 에러와 \"유효한 범위를 벗어났습니다.\"와 같은 구체적인 오류 메시지가 반환되는지 확인합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Isochrone 요청 파라미터 DTO 생성, DTO 필드에 유효성 검증 어노테이션 추가, 전역 예외 처리 핸들러 구현, 커스텀 Validator 구현 (좌표 형식, 이동수단), 그리고 좌표 및 시간 값의 논리적 범위 검증 추가 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 6,
        "title": "GeoJSON Polygon 응답 포맷 검증 및 최적화",
        "description": "Isochrone API의 GeoJSON Polygon 응답 구조를 검증하고, 필요시 포맷을 최적화합니다.",
        "details": "OTP에서 반환하는 GeoJSON 결과를 샘플링하여 좌표, 폴리곤 구조, 속성값 등이 표준 GeoJSON 스펙을 준수하는지 확인. 불필요한 속성 제거 및 응답 크기 최적화.",
        "testStrategy": "GeoJSON Linter 및 샘플 지도 시각화 도구(예: QGIS, Leaflet)로 응답 데이터 검증.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "OTP Isochrone API 샘플 응답 수집 및 분석",
            "description": "Task 4에서 구현된 API 엔드포인트에 실제 요청(예: 서울역 기준 30분, 60분 대중교통)을 보내, 반환되는 GeoJSON 응답의 전체 구조와 데이터를 수집합니다.",
            "dependencies": [],
            "details": "Postman 또는 curl을 사용하여 `/otp/routers/default/isochrone` 엔드포인트에 여러 `cutoffSec` 값으로 요청을 보냅니다. 반환된 JSON 응답을 파일로 저장하여 분석 준비를 합니다.",
            "status": "pending",
            "testStrategy": "API 호출이 성공(200 OK)하고, 유효한 JSON 형식의 응답을 받았는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "GeoJSON 응답의 표준(RFC 7946) 준수 여부 검증",
            "description": "수집된 샘플 응답이 GeoJSON 표준(RFC 7946)을 준수하는지 검증합니다. FeatureCollection, Feature, Geometry (Polygon/MultiPolygon), 좌표 순서 등을 확인합니다.",
            "dependencies": [
              1
            ],
            "details": "`geojson-lint`와 같은 온라인 도구나 라이브러리를 사용하여 수집된 GeoJSON 데이터의 유효성을 검사합니다. 오류나 경고가 발생하는 부분을 기록합니다.",
            "status": "pending",
            "testStrategy": "GeoJSON Linter 통과 여부를 확인하고, QGIS 또는 geojson.io와 같은 도구에서 에러 없이 시각화되는지 검증합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "응답 데이터 최적화를 위한 목표 GeoJSON 포맷 정의",
            "description": "원본 OTP 응답에서 불필요한 속성(properties)을 식별하고, 클라이언트에서 꼭 필요한 정보만 남긴 최적화된 GeoJSON Feature의 속성 구조를 정의합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "원본 속성 중 `time`, `distance` 등 핵심 정보 외의 불필요한 메타데이터를 제거 대상으로 선정합니다. 최종적으로 반환할 GeoJSON Feature의 `properties` 스키마를 문서화합니다.",
            "status": "pending",
            "testStrategy": "정의된 목표 포맷이 API 요구사항을 모두 만족시키는지 동료 검토(peer review)를 통해 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "원본 OTP 응답을 목표 포맷으로 변환하는 로직 구현",
            "description": "OTP 서버로부터 받은 원본 GeoJSON을 입력받아, 3번에서 정의한 목표 포맷으로 변환하는 중간 처리 로직(예: 프록시, 래퍼 함수)을 구현합니다.",
            "dependencies": [
              3
            ],
            "details": "Node.js 또는 Python 기반의 간단한 함수를 작성합니다. 이 함수는 GeoJSON 객체를 순회하며 `properties` 객체에서 불필요한 키-값 쌍을 제거하고, 필요한 경우 구조를 단순화합니다.",
            "status": "pending",
            "testStrategy": "단위 테스트를 작성하여, 샘플 원본 GeoJSON을 입력했을 때 예상되는 목표 포맷 GeoJSON이 정확히 출력되는지 검증합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "변환된 최종 GeoJSON 응답의 유효성 및 시각화 검증",
            "description": "4번에서 구현된 변환 로직을 거친 최종 GeoJSON 결과물이 여전히 유효한 표준을 따르는지, 그리고 지도 상에서 왜곡 없이 정상적으로 렌더링되는지 최종 검증합니다.",
            "dependencies": [
              4
            ],
            "details": "변환된 GeoJSON 파일을 geojson.io, QGIS 등의 도구에 로드하여 폴리곤 경계가 올바르게 표시되는지 확인합니다. 또한, `geojson-lint`로 다시 한번 표준 준수 여부를 검사합니다.",
            "status": "pending",
            "testStrategy": "여러 시간대(cutoffSec) 및 출발지(fromPlace)에 대해 생성된 최적화된 GeoJSON 파일들이 모두 지도 시각화 도구에서 에러 없이 렌더링되는지 확인합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "OTP Isochrone API 샘플 응답 수집 및 분석, GeoJSON 표준 준수 여부 검증, 응답 데이터 최적화를 위한 목표 포맷 정의, 원본 응답을 목표 포맷으로 변환하는 로직 구현, 그리고 변환된 최종 응답의 유효성 및 시각화 검증 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 7,
        "title": "API 성능 측정 및 기본 튜닝",
        "description": "Isochrone API의 응답시간, 메모리 사용량 등 성능을 측정하고, 기본적인 튜닝을 적용합니다.",
        "details": "JMeter, ab 등 벤치마크 도구로 다양한 파라미터(예: 강남 60분 기준)로 API 부하 테스트. OTP JVM 옵션, Docker 리소스 할당, 그래프 캐싱 등 기본 튜닝 적용.",
        "testStrategy": "성능 측정 결과가 PRD 기준(60분 isochrone 15-25초, 메모리 8-12GB) 내에 들어오는지 확인.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "성능 측정 환경 구축 및 벤치마크 시나리오 정의",
            "description": "API 성능 측정을 위한 JMeter 또는 Apache Benchmark(ab) 환경을 설정하고, 부하 테스트에 사용할 시나리오를 구체적으로 정의합니다.",
            "dependencies": [],
            "details": "JMeter를 설치하고 테스트 계획(Test Plan)을 생성합니다. 대상 API 엔드포인트는 '/otp/routers/default/isochrone'로 설정합니다. 주요 테스트 시나리오로 '강남역, 60분, 대중교통'과 '판교역, 30분, 도보' 등 대표적인 케이스를 포함하여 정의합니다.",
            "status": "pending",
            "testStrategy": "JMeter 또는 ab가 설치되고, 정의된 시나리오로 단일 요청을 보내 정상 응답을 받는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "초기(Baseline) 성능 벤치마크 실행 및 결과 수집",
            "description": "튜닝을 적용하기 전 현재 상태의 API 성능을 측정하여 기준 데이터를 확보합니다. 응답 시간, 처리량(TPS), 메모리 사용량, CPU 사용률을 기록합니다.",
            "dependencies": [
              1
            ],
            "details": "정의된 벤치마크 시나리오에 따라 10분 이상 부하 테스트를 실행합니다. JMeter의 Summary Report, Aggregate Graph 등을 통해 결과를 수집하고, `docker stats` 명령어로 컨테이너의 리소스 사용량을 모니터링하여 기록합니다.",
            "status": "pending",
            "testStrategy": "벤치마크 실행 후 결과 리포트 파일(JTL)이 생성되고, 응답 시간 및 리소스 사용량 데이터가 정상적으로 수집되었는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "OTP JVM 옵션 및 Docker 리소스 할당 튜닝",
            "description": "수집된 초기 성능 데이터를 바탕으로 OTP 서버의 JVM 힙 메모리 옵션과 Docker 컨테이너의 리소스 할당량을 조정합니다.",
            "dependencies": [
              2
            ],
            "details": "`docker-compose.yml` 파일 내 OTP 서비스의 `environment` 섹션에서 `JAVA_OPTS`를 수정하여 `-Xmx` (최대 힙 크기) 및 `-Xms` (초기 힙 크기) 값을 조정합니다. 예를 들어, `-Xmx10g -Xms10g` 와 같이 설정합니다. 또한 `deploy.resources.limits`를 사용하여 컨테이너의 CPU 및 메모리 제한을 설정합니다.",
            "status": "pending",
            "testStrategy": "수정된 `docker-compose.yml`로 컨테이너를 재시작한 후, `docker inspect` 명령어나 실행 중인 Java 프로세스 확인을 통해 JVM 옵션이 올바르게 적용되었는지 검증합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "OTP 그래프 캐싱 전략 적용",
            "description": "API 요청 시마다 그래프를 로딩하는 오버헤드를 줄이기 위해, 서버 시작 시점에 그래프를 미리 로드하여 메모리에 상주시키는 캐싱 전략을 적용합니다.",
            "dependencies": [
              2
            ],
            "details": "OTP 서버 실행 명령어에 `--load` 옵션을 명시하여 컨테이너 시작 시점에 그래프 파일(graph.obj)을 즉시 로드하도록 설정합니다. `docker-compose.yml`의 `command` 부분을 수정하여 이 옵션을 추가합니다. 이를 통해 첫 API 요청의 응답 지연을 최소화합니다.",
            "status": "pending",
            "testStrategy": "컨테이너 로그를 확인하여 OTP 서버 시작 시점에 'Graph data loaded.' 와 같은 로그가 출력되는지, 그리고 서버 기동 후 첫 API 요청의 응답 속도가 눈에 띄게 개선되었는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "튜닝 후 성능 재측정 및 결과 비교 분석",
            "description": "JVM, Docker, 캐싱 튜닝이 적용된 상태에서 동일한 시나리오로 벤치마크를 다시 실행하고, 초기 성능 데이터와 비교하여 개선 효과를 검증합니다.",
            "dependencies": [
              3,
              4
            ],
            "details": "초기 벤치마크와 동일한 조건(동일 시나리오, 동일 부하)에서 성능 테스트를 재실행합니다. 튜닝 전/후의 평균 응답 시간, 처리량, 메모리 사용량 변화를 비교 분석하는 보고서를 작성합니다. 목표 성능(60분 isochrone 15-25초, 메모리 8-12GB) 달성 여부를 확인합니다.",
            "status": "pending",
            "testStrategy": "최종 성능 측정 결과가 PRD에 명시된 목표치(응답시간 15-25초, 메모리 8-12GB) 범위 내에 들어오는지 확인하고, 초기 데이터 대비 최소 20% 이상의 성능 향상이 있었는지 검증합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "성능 측정 환경 구축 및 벤치마크 시나리오 정의, 초기 성능 벤치마크 실행 및 결과 수집, OTP JVM 옵션 및 Docker 리소스 할당 튜닝, OTP 그래프 캐싱 전략 적용, 그리고 튜닝 후 성능 재측정 및 결과 비교 분석 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 8,
        "title": "API 안정성 및 장애 대응 테스트",
        "description": "API의 외부 호출 성공률, 장애 상황(데이터 오류, 서버 다운 등)에서의 대응 방안을 검증합니다.",
        "details": "연속 호출, 경계값 입력, 데이터 누락 등 다양한 시나리오에서 API 성공률 측정. 장애 발생 시 로그 기록, 에러 응답, 자동 재시작 등 대응 로직 구현.",
        "testStrategy": "95% 이상 성공률 달성 여부 및 장애 상황에서의 복구/에러 응답 테스트.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "API 안정성 테스트 시나리오 및 성공 기준 정의",
            "description": "부하 테스트, 경계값 테스트, 장애 주입 테스트 등 구체적인 테스트 시나리오를 설계하고, 각 시나리오에 대한 성공 기준(응답 성공률, 응답 시간, 복구 시간 등)을 정량적으로 정의합니다.",
            "dependencies": [],
            "details": "문서(예: Markdown 파일)에 테스트 케이스 ID, 시나리오 설명, 요청 파라미터, 예상 결과, 성공 기준(예: 1000 RPM에서 99% 성공률)을 명시하여 테스트 계획을 수립합니다.",
            "status": "pending",
            "testStrategy": "수립된 테스트 계획이 태스크의 요구사항을 모두 포함하는지 동료 검토를 통해 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "API 부하 테스트 스크립트 개발 및 실행",
            "description": "정의된 시나리오에 따라 API에 연속적인 호출을 보내는 부하 테스트 스크립트를 작성합니다. 스크립트 실행 후 결과를 바탕으로 API 성공률과 평균 응답 시간을 측정합니다.",
            "dependencies": [
              1
            ],
            "details": "Python의 `requests`와 `asyncio` 또는 `k6`, `JMeter`와 같은 부하 테스트 도구를 사용하여 스크립트를 개발합니다. 스크립트는 분당 요청 수(RPM)를 파라미터로 조절할 수 있도록 구현합니다.",
            "status": "pending",
            "testStrategy": "개발된 스크립트가 정의된 부하 테스트 시나리오대로 동작하는지 확인하고, 측정된 성공률과 응답 시간이 성공 기준을 만족하는지 검증합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "예외 및 경계값 처리 테스트 스크립트 개발",
            "description": "유효하지 않은 좌표, 허용 범위를 벗어난 시간(cutoffSec), 지원하지 않는 이동수단, 필수 파라미터 누락 등 다양한 예외 및 경계값 케이스에 대한 테스트 자동화 스크립트를 작성합니다.",
            "dependencies": [
              1
            ],
            "details": "각 예외 케이스별로 API를 호출하고, 예상된 HTTP 상태 코드(예: 400 Bad Request)와 에러 메시지가 응답으로 반환되는지 검증하는 코드를 포함하여 스크립트를 작성합니다.",
            "status": "pending",
            "testStrategy": "모든 예외/경계값 테스트 케이스를 실행하여, API가 예상된 오류 코드와 메시지를 정확히 반환하는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "장애 감지를 위한 로깅 강화 및 Health Check 구현",
            "description": "장애 발생 시 원인 분석을 용이하게 하도록 OTP 서버의 로깅 레벨을 조정하고, Docker 컨테이너의 서비스 상태를 주기적으로 확인할 수 있는 Health Check를 구현합니다.",
            "dependencies": [],
            "details": "`docker-compose.yml` 파일의 OTP 서비스에 `logging` 드라이버 및 옵션을 설정하여 로그를 관리합니다. `healthcheck` 속성을 추가하여 isochrone 엔드포인트에 주기적으로 `curl` 요청을 보내고 정상 응답(HTTP 200)을 확인하도록 구성합니다.",
            "status": "pending",
            "testStrategy": "컨테이너 로그에 에러가 정상적으로 기록되는지 확인하고, `docker inspect` 명령을 통해 health check 상태가 'healthy'로 표시되는지 검증합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "컨테이너 자동 복구 정책 적용 및 장애 시나리오 검증",
            "description": "Docker 서비스가 예기치 않게 종료되었을 때 자동으로 재시작되도록 복구 정책을 설정하고, 실제 장애 상황을 시뮬레이션하여 자동 복구 기능이 정상 동작하는지 검증합니다.",
            "dependencies": [
              4
            ],
            "details": "`docker-compose.yml` 파일의 OTP 서비스에 `restart: unless-stopped` 정책을 추가합니다. `docker kill <container_id>` 명령으로 컨테이너를 강제 종료시킨 후, `docker ps`를 통해 컨테이너가 자동으로 재시작되고 health check가 다시 'healthy' 상태로 전환되는지 확인합니다.",
            "status": "pending",
            "testStrategy": "컨테이너를 수동으로 중지/종료시킨 후, 정의된 시간 내에 자동으로 재시작되어 서비스가 정상화되는지 반복적으로 테스트하여 검증합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "API 안정성 테스트 시나리오 및 성공 기준 정의, API 부하 테스트 스크립트 개발 및 실행, 예외 및 경계값 처리 테스트 스크립트 개발, 장애 감지를 위한 로깅 강화 및 Health Check 구현, 그리고 컨테이너 자동 복구 정책 적용 및 장애 시나리오 검증 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 9,
        "title": "API 사용 예시 및 문서화",
        "description": "Isochrone API의 사용법, 파라미터 설명, 샘플 요청/응답 예시를 README 및 별도 문서로 작성합니다.",
        "details": "README.md에 API 엔드포인트, 파라미터 설명, 샘플 curl 명령어, 응답 예시(GeoJSON) 등 문서화. 오류 코드 및 제한사항 명시.",
        "testStrategy": "문서만 보고 API를 호출할 수 있는지, 샘플 요청이 정상 동작하는지 검증.",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "README.md에 API 개요 및 엔드포인트 정보 추가",
            "description": "README.md 파일에 Isochrone API의 기능, 목적을 설명하는 개요 섹션을 추가하고, 기본 API 엔드포인트 URL을 명시합니다.",
            "dependencies": [],
            "details": "README.md 파일에 'API 사용법' 섹션을 생성하고, API가 어떤 문제를 해결하는지 간략히 설명합니다. `http://<your-server-address>/otp/routers/default/isochrone` 와 같은 형식으로 엔드포인트를 명시합니다.",
            "status": "pending",
            "testStrategy": "README.md 파일을 열어 개요 및 엔드포인트 정보가 명확하게 작성되었는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "API 요청 파라미터 상세 설명 작성",
            "description": "API 호출에 사용되는 모든 쿼리 파라미터(fromPlace, cutoffSec, mode 등)에 대한 상세 설명을 README.md에 표 형식으로 작성합니다.",
            "dependencies": [
              1
            ],
            "details": "각 파라미터에 대해 이름, 타입, 필수 여부, 설명, 예시 값을 포함하는 마크다운 테이블을 작성합니다. 예를 들어, `fromPlace`는 '위도,경도' 형식의 문자열이고 필수 항목임을 명시합니다.",
            "status": "pending",
            "testStrategy": "문서에 명시된 파라미터 설명이 실제 API 동작과 일치하는지, 예시 값이 유효한지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "샘플 API 요청 예시 (curl) 작성",
            "description": "사용자가 바로 복사해서 사용할 수 있는 완전한 `curl` 명령어 예시를 작성합니다. 실제 동작 가능한 파라미터 값들을 사용합니다.",
            "dependencies": [
              2
            ],
            "details": "서울 시내 특정 지점(예: 강남역)의 좌표와 일반적인 이동 시간(예: 3600초)을 파라미터로 사용하여 `curl` 명령어를 구성합니다. URL 인코딩이 필요한 경우 이를 명시합니다.",
            "status": "pending",
            "testStrategy": "README.md에 있는 `curl` 명령어를 터미널에서 직접 실행하여 API가 정상적으로 200 OK 응답을 반환하는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "샘플 API 응답 예시 (GeoJSON) 작성 및 추가",
            "description": "`curl` 예시 요청에 대한 실제 응답(GeoJSON 형식)을 README.md에 추가합니다. 가독성을 위해 일부 축약하거나 접을 수 있는 형태로 제공합니다.",
            "dependencies": [
              3
            ],
            "details": "3번 서브태스크의 `curl` 요청을 실행하여 얻은 GeoJSON 응답을 코드 블록으로 `README.md`에 추가합니다. 내용이 너무 길 경우, 주요 구조(type, features, geometry, properties)를 보여주고 좌표 배열은 일부만 표시합니다.",
            "status": "pending",
            "testStrategy": "문서에 포함된 GeoJSON 응답 예시가 유효한 GeoJSON 형식인지 linter로 검증하고, 구조가 실제 API 응답과 일치하는지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "오류 코드 및 API 제한 사항 문서화",
            "description": "발생 가능한 주요 오류 케이스(예: 잘못된 파라미터)와 해당 HTTP 상태 코드 및 응답 메시지를 정리합니다. API의 성능적 제한 사항도 함께 명시합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "'오류 처리 및 제한 사항' 섹션을 추가합니다. 400 Bad Request(잘못된 좌표), 404 Not Found(경로 없음) 등의 케이스를 설명합니다. 또한, 최대 `cutoffSec` 값이나 동시 요청 수 제한과 같은 서비스 제약 조건을 명시합니다.",
            "status": "pending",
            "testStrategy": "문서에 설명된 오류를 유발하는 요청(예: 유효하지 않은 `fromPlace` 값 전송)을 보내고, 예상된 HTTP 상태 코드와 메시지가 반환되는지 확인합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "README.md에 API 개요 및 엔드포인트 정보 추가, API 요청 파라미터 상세 설명 작성, 샘플 API 요청 예시 (curl) 작성, 샘플 API 응답 예시 (GeoJSON) 작성 및 추가, 그리고 오류 코드 및 API 제한 사항 문서화 단계를 더 상세히 정의할 수 있습니다."
      },
      {
        "id": 10,
        "title": "최종 POC 결과 보고서 작성 및 검증",
        "description": "POC 성공 기준(정상 동작, 성능, 안정성 등)에 대한 최종 결과 보고서 작성 및 검증.",
        "details": "API 정상 동작, 성능(응답시간, 메모리), 성공률 등 주요 지표를 정리하여 보고서 작성. 모든 테스트 케이스 결과 첨부.",
        "testStrategy": "보고서 내 모든 성공 기준이 충족되는지, 외부 검증자(PO 등) 확인 절차 포함.",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "POC 결과 보고서 목차 및 핵심 지표(KPI) 정의",
            "description": "보고서의 전체 구조를 설계하고, POC 성공 여부를 판단할 핵심 지표(정상 동작, 성능, 안정성)를 구체적으로 정의합니다.",
            "dependencies": [],
            "details": "보고서에 포함될 섹션(개요, 테스트 환경, 결과 요약, 상세 분석, 결론)을 확정합니다. 성능 지표(평균/95th 응답시간, 메모리 사용량), 안정성 지표(API 성공률, 에러율) 등 측정 기준을 명시합니다.",
            "status": "pending",
            "testStrategy": "정의된 목차와 KPI가 POC 목표를 모두 포함하는지 팀 내부 리뷰 및 PO 확인을 진행합니다.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "성능 및 안정성 테스트 결과 데이터 수집 및 취합",
            "description": "이전에 수행한 API 성능 테스트(Task 7)와 안정성 테스트(Task 8)의 결과 데이터를 모두 수집하고 정리합니다.",
            "dependencies": [
              1
            ],
            "details": "부하 테스트 결과 로그(JMeter 등), 서버 모니터링(CPU, 메모리) 데이터, API 호출 성공/실패 로그를 취합하여 분석 가능한 형태로 가공합니다.",
            "status": "pending",
            "testStrategy": "수집된 데이터가 1번에서 정의된 KPI 항목들을 모두 측정할 수 있는지 확인하고, 누락된 데이터가 없는지 검토합니다.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "결과 보고서 초안 작성 (데이터 분석 및 시각화 포함)",
            "description": "수집된 데이터를 기반으로 보고서의 본문을 작성합니다. 핵심 지표를 분석하고, 이해하기 쉬운 차트나 표로 시각화하여 포함시킵니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "정의된 목차에 따라 각 섹션을 채웁니다. 응답 시간 분포, 메모리 사용량 추이 등을 그래프로 시각화하고, 테스트 결과에 대한 분석 내용을 서술합니다.",
            "status": "pending",
            "testStrategy": "초안이 보고서 목차와 KPI 정의에 부합하는지, 데이터 해석에 오류가 없는지 동료 검토(peer review)를 진행합니다.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "테스트 케이스 및 증빙 자료 취합 및 부록 작성",
            "description": "보고서의 결론을 뒷받침하는 모든 테스트 케이스의 상세 결과와 관련 로그, 스크린샷 등의 증빙 자료를 취합하여 부록으로 첨부합니다.",
            "dependencies": [
              3
            ],
            "details": "API 기능 테스트, 성능 테스트, 안정성 테스트 등 모든 테스트 시나리오와 실행 결과를 정리합니다. 원본 로그 파일이나 데이터는 별도 파일로 링크하여 첨부합니다.",
            "status": "pending",
            "testStrategy": "부록의 모든 자료가 보고서 본문의 내용과 일치하고, 제3자가 보고 내용을 검증할 수 있을 만큼 충분한지 확인합니다.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "최종 보고서 검토, 승인 및 공유",
            "description": "작성 완료된 보고서 초안과 부록을 포함한 최종본을 관련 이해관계자(PO, 팀 리더 등)에게 공유하고, 검토 및 최종 승인을 받습니다.",
            "dependencies": [
              4
            ],
            "details": "검토 과정에서 발생한 피드백을 반영하여 보고서를 수정합니다. 최종 승인 후, 프로젝트 관리 도구(Confluence 등)나 지정된 저장소에 보고서를 업로드하여 공유합니다.",
            "status": "pending",
            "testStrategy": "PO 및 핵심 이해관계자로부터 보고서 내용에 대한 최종 승인(Sign-off)을 득합니다.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "POC 결과 보고서 목차 및 핵심 지표 정의, 성능 및 안정성 테스트 결과 데이터 수집 및 취합, 결과 보고서 초안 작성 (데이터 분석 및 시각화 포함), 테스트 케이스 및 증빙 자료 취합 및 부록 작성, 그리고 최종 보고서 검토, 승인 및 공유 단계를 더 상세히 정의할 수 있습니다."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-12T17:38:06.306Z",
      "taskCount": 10,
      "completedCount": 1,
      "tags": [
        "master"
      ],
      "created": "2025-11-15T08:57:00.336Z",
      "description": "Tasks for master context",
      "updated": "2025-11-15T09:12:03.352Z"
    }
  }
}